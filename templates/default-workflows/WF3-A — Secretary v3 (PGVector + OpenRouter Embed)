{
  "name": "WF3-A — Secretary v3 (PGVector + OpenRouter Embed)",
  "nodes": [
    {
      "parameters": {
        "content": "# WF3-A — SECRETARY v3\n## PGVector + OpenAI Embedding (No Credential Needed)\n\n### Memory Architecture:\n**search_memories = toolCode**\n→ OpenAI text-embedding-3-small (user's key from tokens)\n→ pgvector cosine search (dim=1536)\n→ similarity threshold > 0.6\n→ top 3 results\n\n### Consistent with WF5-B:\nBoth use text-embedding-3-small dim=1536\n→ embeddings สร้างด้วย model เดียวกัน ✅\n\n### Tools (8):\n1. manage_calendar\n2. manage_tasks\n3. manage_email\n4. manage_chat\n5. manage_social\n6. send_line_notification\n7. search_memories ← OpenAI + pgvector\n8. think\n\n### ENV Required:\n- DATABASE_URL\n- N8N_BASE_URL, N8N_USER_EMAIL, N8N_USER_PASSWORD",
        "height": 480,
        "width": 400,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -192,
        -48
      ],
      "id": "sticky-overview",
      "name": "Overview"
    },
    {
      "parameters": {
        "content": "## DB Table: memory_embeddings\n\n```sql\nCREATE TABLE\n  user_data_schema.memory_embeddings (\n    id SERIAL PRIMARY KEY,\n    user_id TEXT NOT NULL,\n    content TEXT NOT NULL,\n    embedding vector(768),\n    metadata JSONB,\n    created_at TIMESTAMPTZ DEFAULT NOW()\n  );\n\nCREATE INDEX ON\n  user_data_schema.memory_embeddings\n  USING ivfflat (embedding vector_cosine_ops)\n  WITH (lists = 100);\n```\n\n**dim=768** = nomic-embed-text\nWritten by WF5-B Gating Service\n\n## search_memories Flow:\n1. query → POST /api/embeddings (Ollama)\n2. embedding[768] → pgvector <=> operator\n3. similarity > 0.6 → return top 3",
        "height": 380,
        "width": 360,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        232,
        -48
      ],
      "id": "sticky-vector",
      "name": "Vector Store Info"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "wf3a-secretary",
        "responseMode": "lastNode",
        "options": {}
      },
      "id": "webhook-entry",
      "name": "WF3-A Entry",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        672,
        304
      ],
      "webhookId": "wf3a-secretary-entry"
    },
    {
      "parameters": {
        "jsCode": "const payload = $input.first().json.body || $input.first().json;\nreturn {\n  json: {\n    userId: payload.userId,\n    sessionId: payload.sessionId,\n    source: payload.source,\n    message: payload.message || payload.enrichedMessage,\n    originalMessage: payload.originalMessage || payload.message,\n    persona: typeof payload.persona === 'string' ? JSON.parse(payload.persona) : (payload.persona || {}),\n    replyTarget: payload.replyTarget,\n    replyToken: payload.replyToken,\n    timestamp: payload.timestamp,\n    connectedServices: payload.connectedServices || []\n  }\n};"
      },
      "id": "extract-payload",
      "name": "Extract Payload",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        960,
        304
      ]
    },
    {
      "parameters": {
        "jsCode": "// Load Credentials — MULTILINGUAL + USER CONTEXT BUILDER\nconst prev = $('Extract Payload').first().json;\nconst p = prev.persona || {};\nconst t = p.tokens || {};\nconst lang = p.language_preference || 'th';\n\n// i18n Messages\nconst i18nMap = {\n  th: { not_connected: 'ยังไม่ได้เชื่อมต่อ', configure: 'กรุณาตั้งค่าที่ /dashboard/api-settings', success: 'สำเร็จ', error: 'เกิดข้อผิดพลาด', completed: 'เสร็จแล้ว' },\n  en: { not_connected: 'Not connected', configure: 'Please configure at /dashboard/api-settings', success: 'Success', error: 'Error occurred', completed: 'Completed' },\n  ja: { not_connected: '接続されていません', configure: '/dashboard/api-settingsで設定してください', success: '成功しました', error: 'エラーが発生しました', completed: '完了しました' },\n  zh: { not_connected: '未连接', configure: '请在 /dashboard/api-settings 配置', success: '成功', error: '发生错误', completed: '已完成' }\n};\nconst i18n = i18nMap[lang] || i18nMap['en'];\n\nconst get = (envKey, payloadKey) => t[payloadKey] || p[payloadKey] || process.env[envKey] || '';\n\nconst creds = {\n  google_access_token:    get('GOOGLE_ACCESS_TOKEN',    'google_access_token'),\n  google_refresh_token:   get('GOOGLE_REFRESH_TOKEN',   'google_refresh_token'),\n  microsoft_access_token: get('MICROSOFT_ACCESS_TOKEN', 'microsoft_access_token'),\n  outlook_access_token:   get('MICROSOFT_ACCESS_TOKEN', 'microsoft_access_token'),\n  telegram_bot_token:     get('TELEGRAM_BOT_TOKEN',     'telegram_bot_token'),\n  discord_bot_token:      get('DISCORD_BOT_TOKEN',      'discord_bot_token'),\n  slack_bot_token:        get('SLACK_BOT_TOKEN',        'slack_bot_token'),\n  twitter_bearer_token:   get('TWITTER_BEARER_TOKEN',   'twitter_bearer_token'),\n  facebook_access_token:  get('FACEBOOK_ACCESS_TOKEN',  'facebook_access_token'),\n  linkedin_access_token:  get('LINKEDIN_ACCESS_TOKEN',  'linkedin_access_token'),\n  youtube_api_key:        get('YOUTUBE_API_KEY',        'youtube_api_key'),\n  line_notify_token:      get('LINE_NOTIFY_TOKEN',      'line_notify_token'),\n  google_maps_key:        get('GOOGLE_MAPS_API_KEY',    'google_maps_key'),\n  brave_api_key:          get('BRAVE_API_KEY',          'brave_api_key'),\n  openweathermap_key:     get('OPENWEATHERMAP_API_KEY', 'openweathermap_key'),\n  fal_api_key:            get('FAL_API_KEY',            'fal_api_key'),\n  elevenlabs_api_key:     get('ELEVENLABS_API_KEY',     'elevenlabs_api_key'),\n  unsplash_access_key:    get('UNSPLASH_ACCESS_KEY',    'unsplash_access_key'),\n  nutritionix_app_id:     get('NUTRITIONIX_APP_ID',     'nutritionix_app_id'),\n  nutritionix_api_key:    get('NUTRITIONIX_API_KEY',    'nutritionix_api_key'),\n  finnhub_api_key:        get('FINNHUB_API_KEY',        'finnhub_api_key'),\n  ha_url:                 get('HOME_ASSISTANT_URL',     'ha_url'),\n  ha_token:               get('HOME_ASSISTANT_TOKEN',   'ha_token'),\n  sonos_api_url:          get('SONOS_HTTP_API_URL',     'sonos_api_url'),\n  lastfm_api_key:         get('LASTFM_API_KEY',         'lastfm_api_key'),\n  database_url:           get('DATABASE_URL',           'database_url'),\n};\n\nconst connected = Object.entries(creds).filter(([k,v]) => v).map(([k]) => k);\n\n// ── Build User Context String ─────────────────────────────────\nconst userContextParts = [];\n\nif (p.name) userContextParts.push(`Name: ${p.name}`);\nif (p.interests?.length > 0) userContextParts.push(`Interests: ${p.interests.join(', ')}`);\nif (p.personality_notes) userContextParts.push(`Personality: ${p.personality_notes}`);\nif (p.key_facts?.length > 0) {\n  userContextParts.push(`Key Facts:\\n${p.key_facts.map(f => `  - ${f}`).join('\\n')}`);\n}\nif (p.physical_stats && Object.keys(p.physical_stats).length > 0) {\n  const stats = Object.entries(p.physical_stats).map(([k,v]) => `${k}: ${v}`).join(', ');\n  userContextParts.push(`Physical Stats: ${stats}`);\n}\nif (p.ethical_profile) {\n  const ep = p.ethical_profile;\n  userContextParts.push(\n    `Growth Stage: ${ep.growth_stage} (${ep.growth_stage_label})` +\n    (ep.top_strengths?.length > 0 ? ` | Strengths: ${ep.top_strengths.join(', ')}` : '')\n  );\n}\nif (p.relevant_memories?.length > 0) {\n  const memStr = p.relevant_memories.map(m => `  [${m.type}]: ${m.summary}`).join('\\n');\n  userContextParts.push(`Recent Memories (static snapshot):\\n${memStr}`);\n}\n\nconst USER_CONTEXT = userContextParts.length > 0\n  ? `\\n\\n## WHAT I KNOW ABOUT YOU:\\n${userContextParts.join('\\n')}\\n`\n  : '';\n\n// ── Growth Stage Behavior Guide ───────────────────────────────\nconst stage = p.ethical_profile?.growth_stage || 2;\nconst GROWTH_GUIDANCE = {\n  1: 'User is a beginner — use simple language, be very supportive, patient',\n  2: 'User is developing — encourage, guide step by step',\n  3: 'User is growing — challenge with open questions, stimulate thinking',\n  4: 'User is advanced — engage deeply, give space to explore',\n  5: 'User is mature — be a thinking partner, minimal guidance needed'\n}[stage] || '';\n\nconsole.log('[Load Credentials]', {\n  userId: prev.userId?.substring(0, 8) + '...',\n  connected: connected.length,\n  lang,\n  hasUserContext: USER_CONTEXT.length > 0,\n  growthStage: stage\n});\n\nreturn {\n  json: {\n    ...prev,\n    credentials: creds,\n    lang,\n    i18n,\n    USER_CONTEXT,\n    GROWTH_GUIDANCE,\n    stage,\n    _connected: connected\n  }\n};"
      },
      "id": "load-credentials",
      "name": "Load Credentials",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1216,
        304
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.message }}",
        "options": {
          "systemMessage": "=You are Secretary — a world-class personal assistant who knows this user deeply.\n\n{{ $json.USER_CONTEXT }}\n\n## CORE IDENTITY:\nUser: {{ $json.persona.name || 'User' }}\nLanguage: {{ $json.lang }}\nTime: {{ $json.timestamp }}\nGrowth Guidance: {{ $json.GROWTH_GUIDANCE }}\n\n## LANGUAGE RULES:\n**ALWAYS respond in user's preferred language: {{ $json.lang }}**\n- If 'th' → Thai\n- If 'en' → English\n- If 'ja' → Japanese\n- If 'zh' → Chinese\n\n## HOW TO USE USER CONTEXT:\n- Address user by name when appropriate\n- Reference their known interests/facts naturally — NOT robotically\n- Adjust formality based on growth stage ({{ $json.stage }})\n- relevant_memories above = static snapshot (top 3 from WF2)\n- For DEEPER search → use search_memories tool\n\n## MEMORY SEARCH (search_memories tool):\nUse when user asks about:\n- Past experiences (\"ร้านที่เคยไป\", \"places I visited\")\n- Previous conversations (\"เราคุยกันเรื่องอะไร\", \"what did we discuss\")\n- Things they mentioned before (\"สิ่งที่ฉันชอบ\", \"things I like\")\n- Any historical context needed to answer well\n\n## TOOLS:\nmanage_calendar, manage_tasks, manage_email, manage_chat, manage_social, send_line_notification, search_memories, think\n\n## RULES:\n- Confirm before sending important messages\n- If service not connected → inform in user's language\n- Use known preferences for formatting/communication style\n- Never force Thai when user prefers another language\n- Reference user context subtly and naturally"
        }
      },
      "id": "secretary-agent",
      "name": "Secretary Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.8,
      "position": [
        1472,
        192
      ]
    },
    {
      "parameters": {
        "model": "anthropic/claude-sonnet-4-5",
        "options": {
          "maxTokens": 3000
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        1200,
        432
      ],
      "id": "llm-sonnet",
      "name": "OpenRouter LLM (Sonnet 4.5)",
      "credentials": {
        "openRouterApi": {
          "id": "FUm3Fg9B8euy8cH3",
          "name": "OpenRouter"
        }
      }
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $('Load Credentials').item.json.sessionId }}"
      },
      "id": "session-memory",
      "name": "Session Memory",
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        1344,
        432
      ]
    },
    {
      "parameters": {
        "name": "search_memories",
        "description": "Search past conversations and memories semantically using vector similarity. Use when user asks about: past experiences, places visited, previous discussions, things they mentioned before, personal preferences they stated in the past.",
        "jsCode": "// search_memories — OpenAI embedding + pgvector cosine search\n// dim=1536 (text-embedding-3-small) — ตรงกับ WF5-B Process Gating\nconst input = JSON.parse($input.first().json.query || '{}');\nconst query = input.query || input.q || '';\nconst limit = input.limit || 3;\n\nconst creds = $('Load Credentials').first().json.credentials || {};\nconst i18n = $('Load Credentials').first().json.i18n || {};\nconst userId = $('Load Credentials').first().json.userId;\nconst dbUrl = creds.database_url || process.env.DATABASE_URL || '';\nconst openaiKey = creds.google_access_token\n  ? null  // will be overridden below\n  : null;\n\n// Get OpenRouter key from user tokens (ใช้ key เดิมที่มีอยู่แล้ว)\nconst persona = $('Load Credentials').first().json.persona || {};\nconst tokens = persona.tokens || {};\nconst embedKey = tokens.openrouter_access_token || process.env.OPENROUTER_API_KEY || '';\n\nif (!dbUrl) {\n  return { json: { error: `Database ${i18n.not_connected || 'not connected'}`, memories: [] } };\n}\nif (!query || query.length < 3) {\n  return { json: { error: 'Query too short (min 3 chars)', memories: [] } };\n}\nif (!embedKey) {\n  return { json: { error: 'OpenRouter key not configured', memories: [] } };\n}\n\ntry {\n  // ── Step 1: Generate embedding via OpenRouter ─────────────\n  const embedRes = await fetch('https://openrouter.ai/api/v1/embeddings', {\n    method: 'POST',\n    headers: {\n      'Authorization': `Bearer ${embedKey}`,\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      model: 'openai/text-embedding-3-small',\n      input: query\n    })\n  });\n\n  if (!embedRes.ok) {\n    const err = await embedRes.text();\n    return { json: { error: `OpenRouter embed failed: ${embedRes.status} ${err}`, memories: [] } };\n  }\n\n  const embedData = await embedRes.json();\n  const embedding = embedData.data?.[0]?.embedding;\n\n  if (!embedding || !Array.isArray(embedding)) {\n    return { json: { error: 'No embedding returned', memories: [] } };\n  }\n\n  console.log(`[search_memories] dim=${embedding.length} query=\"${query}\"`);\n\n  // ── Step 2: pgvector cosine similarity search ─────────────\n  const { Pool } = require('pg');\n  const pool = new Pool({ connectionString: dbUrl });\n\n  const vectorStr = `[${embedding.join(',')}]`;\n\n  const result = await pool.query(\n    `SELECT\n       content,\n       metadata,\n       created_at,\n       1 - (embedding <=> $1::vector) AS similarity\n     FROM user_data_schema.memory_embeddings\n     WHERE user_id = $2\n       AND embedding IS NOT NULL\n       AND 1 - (embedding <=> $1::vector) > 0.6\n     ORDER BY embedding <=> $1::vector\n     LIMIT $3`,\n    [vectorStr, userId, limit]\n  );\n\n  await pool.end();\n\n  const memories = result.rows.map(r => ({\n    content: r.content,\n    similarity: parseFloat(r.similarity.toFixed(3)),\n    metadata: r.metadata || {},\n    date: new Date(r.created_at).toLocaleDateString('th-TH')\n  }));\n\n  console.log(`[search_memories] Found ${memories.length} | top=${memories[0]?.similarity || 0}`);\n\n  if (memories.length === 0) {\n    return { json: { message: 'No relevant memories found', memories: [], query } };\n  }\n\n  return { json: { memories, count: memories.length, query } };\n\n} catch(err) {\n  console.error('[search_memories] Error:', err.message);\n  return { json: { error: `${i18n.error || 'Error'}: ${err.message}`, memories: [] } };\n}"
      },
      "id": "tool-search-memories",
      "name": "search_memories",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        1488,
        432
      ]
    },
    {
      "parameters": {},
      "id": "think-tool",
      "name": "think",
      "type": "@n8n/n8n-nodes-langchain.toolThink",
      "typeVersion": 1,
      "position": [
        1632,
        432
      ]
    },
    {
      "parameters": {
        "name": "manage_calendar",
        "description": "Create or read Google Calendar events. Actions: create_event, list_events.",
        "jsCode": "// manage_calendar\nconst input = JSON.parse($input.first().json.query || '{}');\nconst creds = $('Load Credentials').first().json.credentials || {};\nconst i18n = $('Load Credentials').first().json.i18n || {};\nconst action = (input.action || 'list_events').toLowerCase();\nconst persona = $('Load Credentials').first().json.persona;\n\nconst baseUrl = 'https://www.googleapis.com/calendar/v3';\nconst token = creds.google_access_token || persona.google_access_token || '';\n\nif (!token) {\n  return { json: { error: `Google Calendar ${i18n.not_connected}`, help: i18n.configure, action } };\n}\n\nlet url, method, body;\n\nif (action === 'create_event') {\n  url = `${baseUrl}/calendars/primary/events`;\n  method = 'POST';\n  body = JSON.stringify({\n    summary: input.title || '',\n    description: input.description || '',\n    location: input.location || '',\n    start: { dateTime: input.start, timeZone: 'Asia/Bangkok' },\n    end: { dateTime: input.end, timeZone: 'Asia/Bangkok' }\n  });\n} else {\n  const timeMin = input.time_min || new Date().toISOString();\n  const timeMax = input.time_max || new Date(Date.now() + 7*24*60*60*1000).toISOString();\n  url = `${baseUrl}/calendars/primary/events?timeMin=${encodeURIComponent(timeMin)}&timeMax=${encodeURIComponent(timeMax)}&singleEvents=true&orderBy=startTime&maxResults=20`;\n  method = 'GET';\n  body = null;\n}\n\nconst response = await fetch(url, {\n  method,\n  headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },\n  body: body || undefined\n});\n\nconst data = await response.json();\nif (!response.ok) return { json: { error: data.error?.message || `Calendar API ${i18n.error}`, status: response.status } };\n\nif (action === 'create_event') {\n  return { json: { success: true, message: i18n.success, event_id: data.id, title: data.summary, start: data.start, link: data.htmlLink } };\n}\n\nconst events = (data.items || []).map(e => ({\n  id: e.id, title: e.summary,\n  start: e.start?.dateTime || e.start?.date,\n  end: e.end?.dateTime || e.end?.date,\n  location: e.location || ''\n}));\nreturn { json: { events, count: events.length } };"
      },
      "id": "tool-calendar",
      "name": "manage_calendar",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        1776,
        432
      ]
    },
    {
      "parameters": {
        "name": "manage_tasks",
        "description": "Create or read Google Tasks. Actions: create_task, list_tasks, complete_task.",
        "jsCode": "// manage_tasks\nconst input = JSON.parse($input.first().json.query || '{}');\nconst action = (input.action || 'list_tasks').toLowerCase();\nconst creds = $('Load Credentials').first().json.credentials || {};\nconst i18n = $('Load Credentials').first().json.i18n || {};\nconst persona = $('Load Credentials').first().json.persona;\nconst token = creds.google_access_token || persona.google_access_token || '';\n\nif (!token) return { json: { error: `Google Tasks ${i18n.not_connected}`, help: i18n.configure } };\n\nconst baseUrl = 'https://tasks.googleapis.com/tasks/v1';\nlet url, method, body;\n\nif (action === 'create_task') {\n  url = `${baseUrl}/lists/@default/tasks`;\n  method = 'POST';\n  body = JSON.stringify({ title: input.title || '', notes: input.notes || '', due: input.due || null });\n} else if (action === 'complete_task') {\n  url = `${baseUrl}/lists/@default/tasks/${input.task_id}`;\n  method = 'PATCH';\n  body = JSON.stringify({ status: 'completed' });\n} else {\n  url = `${baseUrl}/lists/@default/tasks?showCompleted=false&maxResults=20`;\n  method = 'GET';\n  body = null;\n}\n\nconst response = await fetch(url, {\n  method,\n  headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },\n  body: body || undefined\n});\n\nconst data = await response.json();\nif (!response.ok) return { json: { error: data.error?.message || `Tasks API ${i18n.error}` } };\n\nif (action === 'list_tasks') {\n  const tasks = (data.items || []).map(t => ({ id: t.id, title: t.title, due: t.due, status: t.status }));\n  return { json: { tasks, count: tasks.length } };\n}\nreturn { json: { success: true, message: i18n.success, task: { id: data.id, title: data.title, status: data.status } } };"
      },
      "id": "tool-tasks",
      "name": "manage_tasks",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        1952,
        432
      ]
    },
    {
      "parameters": {
        "name": "manage_email",
        "description": "Read or send email. Providers: gmail, outlook. Actions: read_inbox, send_email, search_email.",
        "jsCode": "// manage_email\nconst input = JSON.parse($input.first().json.query || '{}');\nconst creds = $('Load Credentials').first().json.credentials || {};\nconst i18n = $('Load Credentials').first().json.i18n || {};\nconst action = (input.action || 'read_inbox').toLowerCase();\nconst provider = (input.provider || 'gmail').toLowerCase();\nconst persona = $('Load Credentials').first().json.persona;\n\nif (provider === 'gmail') {\n  const token = creds.google_access_token || persona.google_access_token || '';\n  if (!token) return { json: { error: `Gmail ${i18n.not_connected}`, help: i18n.configure } };\n\n  if (action === 'send_email') {\n    const raw = btoa(`To: ${input.to}\\nSubject: ${input.subject}\\nContent-Type: text/plain; charset=utf-8\\n\\n${input.body}`)\n      .replace(/\\+/g,'-').replace(/\\//g,'_').replace(/=+$/,'');\n    const res = await fetch('https://gmail.googleapis.com/gmail/v1/users/me/messages/send', {\n      method: 'POST',\n      headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },\n      body: JSON.stringify({ raw })\n    });\n    const data = await res.json();\n    if (!res.ok) return { json: { error: data.error?.message || i18n.error } };\n    return { json: { success: true, message: i18n.success, message_id: data.id, provider: 'gmail' } };\n  }\n\n  const q = input.query || 'is:unread';\n  const maxResults = input.max_results || 10;\n  const listRes = await fetch(`https://gmail.googleapis.com/gmail/v1/users/me/messages?q=${encodeURIComponent(q)}&maxResults=${maxResults}`, {\n    headers: { 'Authorization': `Bearer ${token}` }\n  });\n  const listData = await listRes.json();\n  const messages = (listData.messages || []).slice(0, 5);\n\n  const details = await Promise.all(messages.map(async m => {\n    const r = await fetch(`https://gmail.googleapis.com/gmail/v1/users/me/messages/${m.id}?format=metadata&metadataHeaders=Subject&metadataHeaders=From`, {\n      headers: { 'Authorization': `Bearer ${token}` }\n    });\n    const d = await r.json();\n    const headers = {};\n    (d.payload?.headers || []).forEach(h => { headers[h.name] = h.value; });\n    return { id: m.id, from: headers['From'], subject: headers['Subject'], snippet: d.snippet };\n  }));\n\n  return { json: { emails: details, count: details.length, provider: 'gmail' } };\n}\n\nif (provider === 'outlook') {\n  const token = creds.outlook_access_token || creds.microsoft_access_token || persona.outlook_access_token || '';\n  if (!token) return { json: { error: `Outlook ${i18n.not_connected}`, help: i18n.configure } };\n\n  if (action === 'send_email') {\n    const res = await fetch('https://graph.microsoft.com/v1.0/me/sendMail', {\n      method: 'POST',\n      headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        message: {\n          subject: input.subject,\n          body: { contentType: 'Text', content: input.body },\n          toRecipients: [{ emailAddress: { address: input.to } }]\n        }\n      })\n    });\n    if (res.status === 202) return { json: { success: true, message: i18n.success, provider: 'outlook' } };\n    const data = await res.json();\n    return { json: { error: data.error?.message || i18n.error } };\n  }\n\n  const filter = action === 'search_email'\n    ? `$search=\"${input.query || ''}\"`\n    : '$filter=isRead eq false';\n  const res = await fetch(`https://graph.microsoft.com/v1.0/me/messages?${filter}&$top=${input.max_results || 10}&$select=id,subject,from,receivedDateTime,bodyPreview`, {\n    headers: { 'Authorization': `Bearer ${token}` }\n  });\n  const data = await res.json();\n  const emails = (data.value || []).map(m => ({\n    id: m.id,\n    from: m.from?.emailAddress?.address,\n    subject: m.subject,\n    snippet: m.bodyPreview,\n    received: m.receivedDateTime\n  }));\n  return { json: { emails, count: emails.length, provider: 'outlook' } };\n}\n\nreturn { json: { error: `Use Gmail or Outlook`, provider } };"
      },
      "id": "tool-email",
      "name": "manage_email",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        2128,
        432
      ]
    },
    {
      "parameters": {
        "name": "manage_chat",
        "description": "Send or read messages. Platforms: telegram, discord, slack.",
        "jsCode": "// manage_chat\nconst input = JSON.parse($input.first().json.query || '{}');\nconst creds = $('Load Credentials').first().json.credentials || {};\nconst i18n = $('Load Credentials').first().json.i18n || {};\nconst action = (input.action || 'send_message').toLowerCase();\nconst platform = (input.platform || '').toLowerCase();\nconst persona = $('Load Credentials').first().json.persona;\n\nif (platform === 'telegram') {\n  const botToken = creds.telegram_bot_token || persona.telegram_bot_token || '';\n  if (!botToken) return { json: { error: `Telegram ${i18n.not_connected}`, help: i18n.configure } };\n\n  if (action === 'send_message') {\n    const res = await fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ chat_id: input.target, text: input.message, parse_mode: 'Markdown' })\n    });\n    const data = await res.json();\n    if (!data.ok) return { json: { error: data.description } };\n    return { json: { success: true, message_id: data.result?.message_id, platform: 'telegram' } };\n  }\n\n  const res = await fetch(`https://api.telegram.org/bot${botToken}/getUpdates?limit=${input.limit || 20}&offset=-${input.limit || 20}`);\n  const data = await res.json();\n  const msgs = (data.result || []).map(u => ({\n    from: u.message?.from?.username || u.message?.from?.first_name,\n    chat_id: u.message?.chat?.id,\n    text: u.message?.text,\n    date: new Date(u.message?.date * 1000).toISOString()\n  })).filter(m => m.text);\n  return { json: { messages: msgs, count: msgs.length, platform: 'telegram' } };\n}\n\nif (platform === 'discord') {\n  const botToken = creds.discord_bot_token || persona.discord_bot_token || '';\n  if (!botToken) return { json: { error: `Discord ${i18n.not_connected}`, help: i18n.configure } };\n\n  if (action === 'send_message') {\n    const res = await fetch(`https://discord.com/api/v10/channels/${input.target}/messages`, {\n      method: 'POST',\n      headers: { 'Authorization': `Bot ${botToken}`, 'Content-Type': 'application/json' },\n      body: JSON.stringify({ content: input.message })\n    });\n    const data = await res.json();\n    if (data.code) return { json: { error: data.message } };\n    return { json: { success: true, message_id: data.id, platform: 'discord' } };\n  }\n\n  const res = await fetch(`https://discord.com/api/v10/channels/${input.target}/messages?limit=${input.limit || 20}`, {\n    headers: { 'Authorization': `Bot ${botToken}` }\n  });\n  const msgs = await res.json();\n  return { json: { messages: (msgs || []).map(m => ({ id: m.id, author: m.author?.username, content: m.content, timestamp: m.timestamp })), platform: 'discord' } };\n}\n\nif (platform === 'slack') {\n  const botToken = creds.slack_bot_token || persona.slack_bot_token || '';\n  if (!botToken) return { json: { error: `Slack ${i18n.not_connected}`, help: i18n.configure } };\n\n  if (action === 'send_message') {\n    const res = await fetch('https://slack.com/api/chat.postMessage', {\n      method: 'POST',\n      headers: { 'Authorization': `Bearer ${botToken}`, 'Content-Type': 'application/json' },\n      body: JSON.stringify({ channel: input.target, text: input.message })\n    });\n    const data = await res.json();\n    if (!data.ok) return { json: { error: data.error } };\n    return { json: { success: true, ts: data.ts, platform: 'slack' } };\n  }\n\n  const res = await fetch(`https://slack.com/api/conversations.history?channel=${input.target}&limit=${input.limit || 20}`, {\n    headers: { 'Authorization': `Bearer ${botToken}` }\n  });\n  const data = await res.json();\n  if (!data.ok) return { json: { error: data.error } };\n  return { json: { messages: (data.messages || []).map(m => ({ ts: m.ts, user: m.user, text: m.text })), platform: 'slack' } };\n}\n\nreturn { json: { error: `${i18n.error}: Unknown platform: ${platform}` } };"
      },
      "id": "tool-chat",
      "name": "manage_chat",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        2304,
        432
      ]
    },
    {
      "parameters": {
        "name": "manage_social",
        "description": "Post or read social media. Platforms: twitter, youtube, facebook, linkedin. Actions: post_tweet, search_tweets, get_timeline (twitter) | search, get_trending (youtube) | post, get_feed (facebook/linkedin).",
        "jsCode": "// manage_social — Twitter, YouTube, Reddit, Facebook, LinkedIn\nconst input = JSON.parse($input.first().json.query || '{}');\nconst creds = $('Load Credentials').first().json.credentials || {};\nconst i18n = $('Load Credentials').first().json.i18n || {};\nconst platform = (input.platform || '').toLowerCase();\nconst action = (input.action || 'post').toLowerCase();\nconst persona = $('Load Credentials').first().json.persona;\n\n// ── Twitter / X ──────────────────────────────────────────────\nif (platform === 'twitter' || platform === 'x') {\n  const token = creds.twitter_bearer_token || persona.twitter_bearer_token || '';\n  if (!token) return { json: { error: `Twitter ${i18n.not_connected}`, help: i18n.configure } };\n\n  if (action === 'post_tweet') {\n    const res = await fetch('https://api.twitter.com/2/tweets', {\n      method: 'POST',\n      headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },\n      body: JSON.stringify({ text: input.text || '' })\n    });\n    const data = await res.json();\n    if (!res.ok) return { json: { error: data.detail || data.title || i18n.error } };\n    return { json: { success: true, tweet_id: data.data?.id, platform: 'twitter' } };\n  }\n\n  if (action === 'search_tweets') {\n    const q = encodeURIComponent(input.query || '');\n    const res = await fetch(`https://api.twitter.com/2/tweets/search/recent?query=${q}&max_results=${input.max_results || 10}`, {\n      headers: { 'Authorization': `Bearer ${token}` }\n    });\n    const data = await res.json();\n    return { json: { tweets: data.data || [], count: (data.data || []).length, platform: 'twitter' } };\n  }\n\n  // get_timeline\n  const res = await fetch(`https://api.twitter.com/2/users/me/timelines/reverse_chronological?max_results=${input.max_results || 10}`, {\n    headers: { 'Authorization': `Bearer ${token}` }\n  });\n  const data = await res.json();\n  return { json: { tweets: data.data || [], count: (data.data || []).length, platform: 'twitter' } };\n}\n\n// ── YouTube ──────────────────────────────────────────────────\nif (platform === 'youtube') {\n  const apiKey = creds.youtube_api_key || persona.youtube_api_key || '';\n  if (!apiKey) return { json: { error: `YouTube ${i18n.not_connected}`, help: i18n.configure } };\n\n  if (action === 'search') {\n    const q = encodeURIComponent(input.query || '');\n    const res = await fetch(`https://www.googleapis.com/youtube/v3/search?part=snippet&q=${q}&type=video&maxResults=${input.max_results || 5}&key=${apiKey}`);\n    const data = await res.json();\n    if (!res.ok) return { json: { error: data.error?.message || i18n.error } };\n    const videos = (data.items || []).map(v => ({\n      id: v.id?.videoId,\n      title: v.snippet?.title,\n      channel: v.snippet?.channelTitle,\n      description: v.snippet?.description?.slice(0, 150),\n      url: `https://youtube.com/watch?v=${v.id?.videoId}`\n    }));\n    return { json: { videos, count: videos.length, platform: 'youtube' } };\n  }\n\n  // get_trending\n  const res = await fetch(`https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics&chart=mostPopular&regionCode=${input.region || 'TH'}&maxResults=${input.max_results || 5}&key=${apiKey}`);\n  const data = await res.json();\n  if (!res.ok) return { json: { error: data.error?.message || i18n.error } };\n  const videos = (data.items || []).map(v => ({\n    id: v.id,\n    title: v.snippet?.title,\n    channel: v.snippet?.channelTitle,\n    views: parseInt(v.statistics?.viewCount || 0).toLocaleString(),\n    url: `https://youtube.com/watch?v=${v.id}`\n  }));\n  return { json: { videos, count: videos.length, platform: 'youtube' } };\n}\n\n// ── Facebook ─────────────────────────────────────────────────\nif (platform === 'facebook') {\n  const token = creds.facebook_access_token || persona.facebook_access_token || '';\n  if (!token) return { json: { error: `Facebook ${i18n.not_connected}`, help: i18n.configure } };\n\n  if (action === 'post') {\n    const pageId = input.page_id || 'me';\n    const res = await fetch(`https://graph.facebook.com/v18.0/${pageId}/feed`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ message: input.message || '', access_token: token })\n    });\n    const data = await res.json();\n    if (!res.ok || data.error) return { json: { error: data.error?.message || i18n.error } };\n    return { json: { success: true, post_id: data.id, platform: 'facebook' } };\n  }\n\n  // get_feed\n  const res = await fetch(`https://graph.facebook.com/v18.0/me/feed?fields=id,message,created_time&limit=${input.limit || 10}&access_token=${token}`);\n  const data = await res.json();\n  if (data.error) return { json: { error: data.error.message } };\n  return { json: { posts: data.data || [], platform: 'facebook' } };\n}\n\n// ── LinkedIn ─────────────────────────────────────────────────\nif (platform === 'linkedin') {\n  const token = creds.linkedin_access_token || persona.linkedin_access_token || '';\n  if (!token) return { json: { error: `LinkedIn ${i18n.not_connected}`, help: i18n.configure } };\n\n  if (action === 'post') {\n    // Get user URN first\n    const profileRes = await fetch('https://api.linkedin.com/v2/userinfo', {\n      headers: { 'Authorization': `Bearer ${token}` }\n    });\n    const profile = await profileRes.json();\n    const authorUrn = `urn:li:person:${profile.sub}`;\n\n    const res = await fetch('https://api.linkedin.com/v2/ugcPosts', {\n      method: 'POST',\n      headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        author: authorUrn,\n        lifecycleState: 'PUBLISHED',\n        specificContent: {\n          'com.linkedin.ugc.ShareContent': {\n            shareCommentary: { text: input.text || '' },\n            shareMediaCategory: 'NONE'\n          }\n        },\n        visibility: { 'com.linkedin.ugc.MemberNetworkVisibility': 'PUBLIC' }\n      })\n    });\n    const data = await res.json();\n    if (!res.ok) return { json: { error: data.message || i18n.error } };\n    return { json: { success: true, post_id: data.id, platform: 'linkedin' } };\n  }\n\n  // get_feed\n  const res = await fetch('https://api.linkedin.com/v2/shares?q=owners&owners=me&count=10', {\n    headers: { 'Authorization': `Bearer ${token}` }\n  });\n  const data = await res.json();\n  if (!res.ok) return { json: { error: data.message || i18n.error } };\n  return { json: { shares: data.elements || [], platform: 'linkedin' } };\n}\n\nreturn { json: { error: `${i18n.error}: Unknown platform '${platform}'. Use: twitter, youtube, facebook, linkedin` } };"
      },
      "id": "tool-social",
      "name": "manage_social",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        2480,
        432
      ]
    },
    {
      "parameters": {
        "name": "send_line_notification",
        "description": "Send urgent notification via LINE Notify.",
        "jsCode": "const input = JSON.parse($input.first().json.query || '{}');\nconst creds = $('Load Credentials').first().json.credentials || {};\nconst i18n = $('Load Credentials').first().json.i18n || {};\nconst token = creds.line_notify_token || '';\n\nif (!token) return { json: { error: `LINE Notify ${i18n.not_connected}`, help: i18n.configure } };\n\nconst message = input.message || '';\nif (!message) return { json: { error: i18n.error || 'Message required' } };\n\ntry {\n  const res = await fetch('https://notify-api.line.me/api/notify', {\n    method: 'POST',\n    headers: {\n      'Authorization': `Bearer ${token}`,\n      'Content-Type': 'application/x-www-form-urlencoded'\n    },\n    body: new URLSearchParams({ message })\n  });\n  const data = await res.json();\n  if (!res.ok || data.status !== 200) return { json: { error: i18n.error, details: data.message } };\n  return { json: { success: true, message: i18n.success, status: data.status } };\n} catch (error) {\n  return { json: { error: i18n.error, details: error.message } };\n}"
      },
      "id": "tool-line",
      "name": "send_line_notification",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        2656,
        432
      ]
    },
    {
      "parameters": {
        "jsCode": "const agentOutput = $input.first().json.output || $input.first().json.text || 'Done';\nconst prev = $('Extract Payload').item.json;\nreturn {\n  json: {\n    ...prev,\n    agentOutput: agentOutput,\n    agentCategory: 'secretary',\n    processedAt: new Date().toISOString()\n  }\n};"
      },
      "id": "format-output",
      "name": "Format Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2800,
        192
      ]
    }
  ],
  "connections": {
    "WF3-A Entry": {
      "main": [
        [
          {
            "node": "Extract Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Payload": {
      "main": [
        [
          {
            "node": "Load Credentials",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Credentials": {
      "main": [
        [
          {
            "node": "Secretary Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Secretary Agent": {
      "main": [
        [
          {
            "node": "Format Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter LLM (Sonnet 4.5)": {
      "ai_languageModel": [
        [
          {
            "node": "Secretary Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Session Memory": {
      "ai_memory": [
        [
          {
            "node": "Secretary Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "search_memories": {
      "ai_tool": [
        [
          {
            "node": "Secretary Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "think": {
      "ai_tool": [
        [
          {
            "node": "Secretary Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "manage_calendar": {
      "ai_tool": [
        [
          {
            "node": "Secretary Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "manage_tasks": {
      "ai_tool": [
        [
          {
            "node": "Secretary Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "manage_email": {
      "ai_tool": [
        [
          {
            "node": "Secretary Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "manage_chat": {
      "ai_tool": [
        [
          {
            "node": "Secretary Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "manage_social": {
      "ai_tool": [
        [
          {
            "node": "Secretary Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "send_line_notification": {
      "ai_tool": [
        [
          {
            "node": "Secretary Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "c3a8077648ce894608db1ade94831096370fb6a0453430d193f6c81b3c8cc1cb"
  },
  "tags": []
}
