{
  "name": "WF5 — Memory Consolidator",
  "nodes": [
    {
      "parameters": {
        "content": "# WF5 — Memory Consolidator\n## ทำงานทุก 6 ชั่วโมง\n\n### Flow:\nCron → Get Active Users → Split (batch)\n→ Load Messages + Load Persona (parallel)\n→ Merge → LLM Extract Memory\n→ Parse → Save to DB + Mark Processed\n\n### Fixes จาก original:\n1. LLM: OpenRouter (Haiku) แทน OpenAI node\n2. System Prompt: JSON format ชัดเจน\n3. Table: `\"User\"` (public schema) ตรงกับ WF2\n4. SQL: escape single quotes ป้องกัน injection\n5. Parse: อ่าน field ถูกต้อง + error handling\n6. Physical_stats: merge ไม่ overwrite\n7. Log: บันทึก heartbeat_log สำหรับ WF-Heartbeat",
        "height": 320,
        "width": 380,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -448,
        240
      ],
      "id": "8bf90d12-716b-442a-93da-05c7dc3e74bc",
      "name": "WF5 Overview"
    },
    {
      "parameters": {
        "content": "## Tables ที่ใช้\n\n**อ่าน:**\n- `user_data_schema.chat_sessions`\n- `user_data_schema.raw_messages`\n- `\"User\"` (public schema — ตรงกับ WF2)\n\n**เขียน:**\n- `\"User\"` → update persona JSONB\n- `user_data_schema.raw_messages` → mark processed\n- `user_data_schema.memory_facts` → key facts log\n- `user_data_schema.heartbeat_log` → memory event\n\n## Required columns ใน \"User\":\n```sql\nALTER TABLE \"User\" ADD COLUMN IF NOT EXISTS\n  persona JSONB DEFAULT '{}'::jsonb;\nALTER TABLE \"User\" ADD COLUMN IF NOT EXISTS\n  updated_at TIMESTAMPTZ DEFAULT NOW();\n```",
        "height": 320,
        "width": 360,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -448,
        640
      ],
      "id": "6de7c321-9ef4-4b2b-a741-3d6a9e36f3ff",
      "name": "Schema Notes"
    },
    {
      "parameters": {
        "model": "anthropic/claude-haiku-4-5",
        "options": {
          "maxTokens": 1000
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        1264,
        784
      ],
      "id": "e33cc258-9828-4db2-8eb2-499f92df1fba",
      "name": "LLM Memory Extractor (Haiku)",
      "credentials": {
        "openRouterApi": {
          "id": "FUm3Fg9B8euy8cH3",
          "name": "OpenRouter - 2026-02-14T03:30"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Analyze this conversation and extract memory updates.\n\nUSER INFO:\nName: {{ $json.userMeta.name }}\nLanguage: {{ $json.userMeta.language }}\nTimezone: {{ $json.userMeta.timezone }}\n\nCURRENT PERSONA:\n{{ JSON.stringify($json.currentPersona, null, 2) }}\n\nCONVERSATION (last 7 hours, {{ $json.messageCount }} messages):\n{{ $json.conversation }}",
        "batching": {}
      },
      "id": "811b832f-73b9-402d-a7b6-fda4bc06c635",
      "name": "LLM Chain (Memory Extract)",
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.9,
      "position": [
        1264,
        544
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false
          },
          "conditions": [
            {
              "leftValue": "={{ $json.skip }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "notEquals"
              }
            }
          ]
        },
        "options": {}
      },
      "id": "5104040c-a814-4727-8144-a313fc36fe27",
      "name": "Should Save?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1744,
        544
      ]
    },
    {
      "parameters": {
        "jsCode": "// Save updated persona + mark messages as processed\nconst item = $input.first().json;\nconst userId = item.userId;\nconst updatedPersona = item.updatedPersona;\nconst keyFacts = item.keyFacts || [];\n\nconst dbUrl = process.env.DATABASE_URL || '';\nif (!dbUrl) {\n  console.error('[WF5 Save] DATABASE_URL not set');\n  return { json: { ...item, saved: false, reason: 'no_db_url' } };\n}\n\ntry {\n  const { Pool } = require('pg');\n  const pool = new Pool({ connectionString: dbUrl });\n\n  // FIXED: use parameterized query — no SQL injection\n  // 1. Update persona in \"User\" table (same table as WF2)\n  await pool.query(\n    'UPDATE \"User\" SET persona = $1::jsonb, updated_at = NOW() WHERE id = $2',\n    [JSON.stringify(updatedPersona), userId]\n  );\n\n  // 2. Mark messages as processed\n  await pool.query(\n    `UPDATE user_data_schema.raw_messages\n     SET processed_for_memory = true\n     WHERE session_id IN (\n       SELECT id FROM user_data_schema.chat_sessions\n       WHERE user_id = $1\n     )\n     AND processed_for_memory = false\n     AND created_at > NOW() - INTERVAL '7 hours'`,\n    [userId]\n  );\n\n  // 3. Save key_facts to memory_facts table (if exists)\n  if (keyFacts.length > 0) {\n    for (const fact of keyFacts) {\n      try {\n        await pool.query(\n          `INSERT INTO user_data_schema.memory_facts (user_id, fact, source, created_at)\n           VALUES ($1, $2, 'wf5_consolidator', NOW())\n           ON CONFLICT DO NOTHING`,\n          [userId, fact]\n        );\n      } catch(e) {\n        // Table might not exist — skip silently\n        console.log('[WF5 Save] memory_facts insert skipped:', e.message);\n        break;\n      }\n    }\n  }\n\n  // 4. Log to heartbeat_log (WF-Heartbeat reads this)\n  try {\n    await pool.query(\n      `INSERT INTO user_data_schema.heartbeat_log\n         (user_id, heartbeat_type, trigger_type, action, urgency, delivered, created_at)\n       VALUES ($1, 'memory_consolidation', 'cron_6h', 'memory_updated', 'low', true, NOW())`,\n      [userId]\n    );\n  } catch(e) {\n    console.log('[WF5 Save] heartbeat_log insert skipped:', e.message);\n  }\n\n  await pool.end();\n\n  console.log(`[WF5 Save] ✅ userId: ${userId.substring(0,8)}... | facts saved: ${keyFacts.length}`);\n  return {\n    json: {\n      ...item,\n      saved: true,\n      factsCount: keyFacts.length,\n      personaKeys: Object.keys(updatedPersona).length\n    }\n  };\n\n} catch(err) {\n  console.error('[WF5 Save] DB error:', err.message);\n  return { json: { ...item, saved: false, reason: err.message } };\n}"
      },
      "id": "301d4231-dd1d-4974-9b0d-81eeb0b4d699",
      "name": "Save to DB",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1968,
        544
      ]
    },
    {
      "parameters": {
        "jsCode": "// Silent skip — log only\nconst item = $input.first().json;\nconsole.log('[WF5 Skip]', item.userId?.substring(0,8), '| reason:', item.skipReason || 'parse_error_or_no_data');\nreturn { json: { status: 'skipped', userId: item.userId, reason: item.skipReason } };"
      },
      "id": "c4042121-c0de-492a-9c15-976248bebb78",
      "name": "Silent Skip",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1968,
        704
      ]
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 6
            }
          ]
        }
      },
      "id": "6d271155-b633-46b6-987e-05270a4a7c5c",
      "name": "Cron: Every 6h1",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        16,
        544
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT DISTINCT s.user_id\nFROM user_data_schema.chat_sessions s\nJOIN user_data_schema.raw_messages m ON m.session_id = s.id\nWHERE m.created_at > NOW() - INTERVAL '7 hours'\n  AND m.processed_for_memory = false\nGROUP BY s.user_id\nHAVING COUNT(m.id) >= 3",
        "options": {}
      },
      "id": "b3b48522-5703-4d9e-802e-2942a617690c",
      "name": "Get Active Users1",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        256,
        544
      ],
      "credentials": {
        "postgres": {
          "id": "BLko8EzXDNKsZOal",
          "name": "User Postgres - 2026-02-14T02:34"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "65258387-1a94-4de8-9657-e917bbe3ffc9",
      "name": "Split Users1",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        496,
        544
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=SELECT m.role, m.content, m.created_at, m.category\nFROM user_data_schema.raw_messages m\nJOIN user_data_schema.chat_sessions s ON m.session_id = s.id\nWHERE s.user_id = '{{ $json.user_id }}'\n  AND m.created_at > NOW() - INTERVAL '7 hours'\n  AND m.processed_for_memory = false\nORDER BY m.created_at ASC\nLIMIT 100",
        "options": {}
      },
      "id": "c0d4832d-b0be-4fbf-8e20-262bad1fbb8f",
      "name": "Load Unprocessed Messages1",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        768,
        400
      ],
      "credentials": {
        "postgres": {
          "id": "BLko8EzXDNKsZOal",
          "name": "User Postgres - 2026-02-14T02:34"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=SELECT id, name, email, language_preference, timezone,\n       persona, \"subscriptionTier\"\nFROM \"User\"\nWHERE id = '{{ $('Split Users1').item.json.user_id }}'\nLIMIT 1",
        "options": {}
      },
      "id": "96494bfe-6f12-40e6-8387-4ab541146bd2",
      "name": "Load Current Persona1",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        768,
        688
      ],
      "credentials": {
        "postgres": {
          "id": "BLko8EzXDNKsZOal",
          "name": "User Postgres - 2026-02-14T02:34"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Merge messages + persona for LLM analysis\nconst msgs = $('Load Unprocessed Messages1').all().map(i => i.json);\nconst personaRow = $('Load Current Persona1').first()?.json || {};\nconst userId = $('Split Users1').item.json.user_id;\n\n// Parse persona JSONB (may come as string or object)\nlet currentPersona = {};\ntry {\n  const raw = personaRow.persona;\n  currentPersona = typeof raw === 'string' ? JSON.parse(raw) : (raw || {});\n} catch(e) {\n  currentPersona = {};\n}\n\n// Build conversation text (cap at ~3000 chars for LLM)\nconst conversation = msgs\n  .map(m => `[${m.role?.toUpperCase() || 'USER'}]: ${m.content}`)\n  .join('\\n')\n  .slice(0, 3000);\n\nconst userMeta = {\n  name: personaRow.name || 'User',\n  language: personaRow.language_preference || 'th',\n  timezone: personaRow.timezone || 'Asia/Bangkok'\n};\n\nconsole.log(`[WF5 Merge] userId: ${userId.substring(0,8)}... | messages: ${msgs.length} | personaKeys: ${Object.keys(currentPersona).length}`);\n\nreturn {\n  json: {\n    userId,\n    userMeta,\n    currentPersona,\n    conversation,\n    messageCount: msgs.length\n  }\n};"
      },
      "id": "7b1b0b91-9e30-4ff4-ad33-437047fe67df",
      "name": "Merge for Analysis1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1040,
        544
      ]
    },
    {
      "parameters": {
        "jsCode": "// Parse LLM memory output and merge with current persona\nconst item = $input.first().json;\n// FIXED: chainLlm outputs to $json.text\nconst rawOutput = item.text || item.output || item.response || '{}';\nconst userId = $('Merge for Analysis1').item.json.userId;\nconst currentPersona = $('Merge for Analysis1').item.json.currentPersona;\nconst userMeta = $('Merge for Analysis1').item.json.userMeta;\n\nlet memoryUpdate = {};\ntry {\n  const cleaned = rawOutput.replace(/```json|```/g, '').trim();\n  memoryUpdate = JSON.parse(cleaned);\n} catch(e) {\n  console.error('[WF5 Parse] JSON parse error:', e.message, '| raw:', rawOutput.slice(0, 200));\n  return {\n    json: {\n      userId,\n      updatedPersona: currentPersona,\n      keyFacts: [],\n      emotionalPatterns: [],\n      languageDetected: userMeta.language,\n      skip: true,\n      skipReason: 'json_parse_error'\n    }\n  };\n}\n\nconst pu = memoryUpdate.persona_updates || {};\n\n// Safe merge — never overwrite existing with empty\nconst mergedInterests = [...new Set([\n  ...(currentPersona.interests || []),\n  ...(pu.interests || [])\n])];\n\nconst mergedPreferences = {\n  ...(currentPersona.preferences || {}),\n  ...(pu.preferences || {})\n};\n\n// physical_stats: only merge if new data has content\nconst mergedPhysicalStats = {\n  ...(currentPersona.physical_stats || {}),\n  ...(Object.keys(pu.physical_stats || {}).length > 0 ? pu.physical_stats : {})\n};\n\nconst updatedPersona = {\n  ...currentPersona,\n  interests: mergedInterests,\n  preferences: mergedPreferences,\n  physical_stats: mergedPhysicalStats,\n  // Only update personality_notes if LLM returned something\n  personality_notes: pu.personality_notes || currentPersona.personality_notes || null,\n  // Track language\n  language_preference: memoryUpdate.language_detected || currentPersona.language_preference || userMeta.language,\n  // Metadata\n  _last_memory_update: new Date().toISOString()\n};\n\nconsole.log(`[WF5 Parse] userId: ${userId.substring(0,8)}... | facts: ${(memoryUpdate.key_facts || []).length} | interests_new: ${(pu.interests || []).length}`);\n\nreturn {\n  json: {\n    userId,\n    updatedPersona,\n    keyFacts: memoryUpdate.key_facts || [],\n    emotionalPatterns: memoryUpdate.emotional_patterns || [],\n    languageDetected: memoryUpdate.language_detected || userMeta.language,\n    skip: false\n  }\n};"
      },
      "id": "8600011e-73cb-49aa-8d4f-b427f9742917",
      "name": "Parse Memory Update1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1520,
        544
      ]
    }
  ],
  "pinData": {},
  "connections": {
    "LLM Memory Extractor (Haiku)": {
      "ai_languageModel": [
        [
          {
            "node": "LLM Chain (Memory Extract)",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "LLM Chain (Memory Extract)": {
      "main": [
        [
          {
            "node": "Parse Memory Update1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Should Save?": {
      "main": [
        [
          {
            "node": "Save to DB",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Silent Skip",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cron: Every 6h1": {
      "main": [
        [
          {
            "node": "Get Active Users1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Active Users1": {
      "main": [
        [
          {
            "node": "Split Users1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Users1": {
      "main": [
        [
          {
            "node": "Load Unprocessed Messages1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Load Current Persona1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Unprocessed Messages1": {
      "main": [
        [
          {
            "node": "Merge for Analysis1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Current Persona1": {
      "main": [
        [
          {
            "node": "Merge for Analysis1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge for Analysis1": {
      "main": [
        [
          {
            "node": "LLM Chain (Memory Extract)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Memory Update1": {
      "main": [
        [
          {
            "node": "Should Save?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "binaryMode": "separate",
    "availableInMCP": false
  },
  "versionId": "47b836e4-eac5-40b0-97a8-7e0f0cd12c94",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "c3a8077648ce894608db1ade94831096370fb6a0453430d193f6c81b3c8cc1cb"
  },
  "id": "igrEWaFnSmzEjMCm",
  "tags": []
}
