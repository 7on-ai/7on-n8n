{
  "name": "WF3-F — Home Mate Agent v3 (Code Tool)",
  "nodes": [
    {
      "parameters": {
        "content": "# WF3-F — HOME MATE v3\n## 4 Code Tools\n1. control_spotify → play/search/control/playlist\n2. control_sonos   → rooms/volume/play/group\n3. control_home    → Home Assistant + Ambient modes\n4. music_lookup    → Last.fm + YouTube Music\n\nModel: Haiku (fast actions)\n\n## MULTILINGUAL SUPPORT:\n- th / en / ja / zh\n- i18n via Load Credentials node\n- Ambient mode descriptions แปล 4 ภาษา\n- All creds bugs fixed",
        "height": 280,
        "width": 360,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -304,
        -16
      ],
      "id": "c8c71725-2f43-4b1b-b84b-a18f43c164f9",
      "name": "Home Mate v3 Overview1"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "wf3f-homemate",
        "responseMode": "lastNode",
        "options": {}
      },
      "id": "c758ec7c-c192-4299-a1a7-a891654ac48b",
      "name": "WF3-F Entry1",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        560,
        336
      ],
      "webhookId": "wf3f-homemate-entry"
    },
    {
      "parameters": {
        "jsCode": "const p = $input.first().json.body || $input.first().json;\nreturn { json: {\n  userId: p.userId, sessionId: p.sessionId, source: p.source,\n  message: p.message || p.enrichedMessage,\n  originalMessage: p.originalMessage || p.message,\n  persona: typeof p.persona === 'string' ? JSON.parse(p.persona) : (p.persona || {}),\n  replyTarget: p.replyTarget, replyToken: p.replyToken, timestamp: p.timestamp\n}};"
      },
      "id": "16270124-ae4f-4a80-90bd-ebe4b0ff52c1",
      "name": "Extract Payload1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        848,
        336
      ]
    },
    {
      "parameters": {
        "jsCode": "// Load Credentials — MULTILINGUAL + i18n\n// FIXED: reference Extract Payload1 (not Extract Payload)\nconst prev = $('Extract Payload1').first().json;\nconst p = prev.persona || {};\nconst t = p.tokens || {};\nconst lang = p.language_preference || 'th';\n\n// FIXED: use i18nMap to avoid i18n.en self-reference bug\nconst i18nMap = {\n  th: {\n    not_connected: 'ยังไม่ได้เชื่อมต่อ',\n    configure: 'กรุณาตั้งค่าที่ /dashboard/api-settings',\n    success: 'สำเร็จ',\n    error: 'เกิดข้อผิดพลาด',\n    completed: 'เสร็จแล้ว',\n    query_required: 'กรุณาระบุคำค้นหา',\n    room_required: 'กรุณาระบุชื่อห้อง',\n    name_required: 'กรุณาระบุชื่อ',\n    youtube_note: 'YouTube Music ต้องเปิดใน app/browser ครับ',\n    sonos_note: 'กรุณาตรวจสอบว่า node-sonos-http-api ทำงานอยู่'\n  },\n  en: {\n    not_connected: 'Not connected',\n    configure: 'Please configure at /dashboard/api-settings',\n    success: 'Success',\n    error: 'Error occurred',\n    completed: 'Completed',\n    query_required: 'query is required',\n    room_required: 'room name is required',\n    name_required: 'name is required',\n    youtube_note: 'YouTube Music must be opened in app/browser',\n    sonos_note: 'Please check that node-sonos-http-api is running'\n  },\n  ja: {\n    not_connected: '接続されていません',\n    configure: '/dashboard/api-settingsで設定してください',\n    success: '成功しました',\n    error: 'エラーが発生しました',\n    completed: '完了しました',\n    query_required: '検索クエリが必要です',\n    room_required: 'ルーム名が必要です',\n    name_required: '名前が必要です',\n    youtube_note: 'YouTube Musicはアプリ/ブラウザで開いてください',\n    sonos_note: 'node-sonos-http-apiが起動しているか確認してください'\n  },\n  zh: {\n    not_connected: '未连接',\n    configure: '请在 /dashboard/api-settings 配置',\n    success: '成功',\n    error: '发生错误',\n    completed: '已完成',\n    query_required: '需要搜索关键词',\n    room_required: '需要房间名称',\n    name_required: '需要名称',\n    youtube_note: 'YouTube Music 需要在应用/浏览器中打开',\n    sonos_note: '请检查 node-sonos-http-api 是否正在运行'\n  }\n};\n\nconst i18n = i18nMap[lang] || i18nMap['en'];\n\nconst get = (envKey, payloadKey) =>\n  t[payloadKey] || p[payloadKey] || process.env[envKey] || '';\n\nconst creds = {\n  google_access_token:    get('GOOGLE_ACCESS_TOKEN',    'google_access_token'),\n  google_refresh_token:   get('GOOGLE_REFRESH_TOKEN',   'google_refresh_token'),\n  microsoft_access_token: get('MICROSOFT_ACCESS_TOKEN', 'microsoft_access_token'),\n  outlook_access_token:   get('MICROSOFT_ACCESS_TOKEN', 'microsoft_access_token'),\n  telegram_bot_token:     get('TELEGRAM_BOT_TOKEN',     'telegram_bot_token'),\n  discord_bot_token:      get('DISCORD_BOT_TOKEN',      'discord_bot_token'),\n  slack_bot_token:        get('SLACK_BOT_TOKEN',        'slack_bot_token'),\n  twitter_bearer_token:   get('TWITTER_BEARER_TOKEN',   'twitter_bearer_token'),\n  facebook_access_token:  get('FACEBOOK_ACCESS_TOKEN',  'facebook_access_token'),\n  linkedin_access_token:  get('LINKEDIN_ACCESS_TOKEN',  'linkedin_access_token'),\n  spotify_access_token:   get('SPOTIFY_ACCESS_TOKEN',   'spotify_access_token'),\n  youtube_api_key:        get('YOUTUBE_API_KEY',        'youtube_api_key'),\n  line_notify_token:      get('LINE_NOTIFY_TOKEN',      'line_notify_token'),\n  google_maps_key:        get('GOOGLE_MAPS_API_KEY',    'google_maps_key'),\n  brave_api_key:          get('BRAVE_API_KEY',          'brave_api_key'),\n  openweathermap_key:     get('OPENWEATHERMAP_API_KEY', 'openweathermap_key'),\n  fal_api_key:            get('FAL_API_KEY',            'fal_api_key'),\n  elevenlabs_api_key:     get('ELEVENLABS_API_KEY',     'elevenlabs_api_key'),\n  unsplash_access_key:    get('UNSPLASH_ACCESS_KEY',    'unsplash_access_key'),\n  nutritionix_app_id:     get('NUTRITIONIX_APP_ID',     'nutritionix_app_id'),\n  nutritionix_api_key:    get('NUTRITIONIX_API_KEY',    'nutritionix_api_key'),\n  finnhub_api_key:        get('FINNHUB_API_KEY',        'finnhub_api_key'),\n  ha_url:                 get('HOME_ASSISTANT_URL',      'ha_url'),\n  ha_token:               get('HOME_ASSISTANT_TOKEN',    'ha_token'),\n  sonos_api_url:          get('SONOS_HTTP_API_URL',     'sonos_api_url'),\n  lastfm_api_key:         get('LASTFM_API_KEY',         'lastfm_api_key'),\n  lastfm_username:        get('LASTFM_USERNAME',        'lastfm_username'),\n  lastfm_session_key:     get('LASTFM_SESSION_KEY',     'lastfm_session_key'),\n  gating_service_url:     get('GATING_SERVICE_URL',     'gating_service_url'),\n  internal_auth_token:    get('INTERNAL_AUTH_TOKEN',    'internal_auth_token'),\n  n8n_base_url:           get('N8N_BASE_URL',           'n8n_base_url'),\n  database_url:           get('DATABASE_URL',           'database_url')\n};\n\nconst connected = Object.entries(creds).filter(([k,v]) => v).map(([k]) => k);\n\nconsole.log('[Load Credentials]', {\n  userId: prev.userId?.substring(0, 8) + '...',\n  connected: connected.length,\n  lang\n});\n\nreturn {\n  json: {\n    ...prev,\n    credentials: creds,\n    lang,\n    i18n,\n    _connected: connected\n  }\n};"
      },
      "id": "dcb11783-a11f-4ec5-9b2a-9dcec42caff9",
      "name": "Load Credentials",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1104,
        336
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.message }}",
        "options": {
          "systemMessage": "=You are Home Mate — ambient intelligence for music and smart home.\n\nUser: {{ $json.persona.name || 'User' }}\nLanguage: {{ $json.persona.language_preference || 'th' }}\n\n## LANGUAGE RULES:\n**ALWAYS respond in user's preferred language: {{ $json.persona.language_preference }}**\n- If 'th' → Thai\n- If 'en' → English\n- If 'ja' → Japanese\n- If 'zh' → Chinese\n\n## AMBIENT MODES:\n- morning: Bright 5000K + energy music\n- work: Neutral 4000K + lo-fi\n- relax: Warm 2700K + chill\n- sleep: Lights off + nature sounds\n- movie: Dim 2200K + no music\n- study: Bright 6000K + classical\n\n## TOOLS:\ncontrol_spotify, control_sonos, control_home, music_lookup, think"
        }
      },
      "id": "11c6c8aa-4bf0-4d10-8f69-c39f04f1835e",
      "name": "Home Mate Agent1",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.8,
      "position": [
        1600,
        224
      ]
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $('Load Credentials').item.json.sessionId }}"
      },
      "id": "c7e294eb-ee04-4c72-9d6e-a04814f0c57f",
      "name": "Session Memory1",
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        1584,
        464
      ]
    },
    {
      "parameters": {},
      "id": "d27f185d-c5be-4bdb-8bb2-90a76f44f4c1",
      "name": "think1",
      "type": "@n8n/n8n-nodes-langchain.toolThink",
      "typeVersion": 1,
      "position": [
        1760,
        464
      ]
    },
    {
      "parameters": {
        "name": "control_spotify",
        "description": "Control Spotify playback and library. action: play, pause, resume, next, prev, set_volume, search, now_playing, list_devices, create_playlist, set_shuffle.",
        "jsCode": "const input = JSON.parse($input.first().json.query || '{}');\nconst ctx = $('Load Credentials').first().json;\nconst creds = ctx.credentials || {};\nconst i18n = ctx.i18n || {};\nconst action = (input.action || 'now_playing').toLowerCase();\nconst token = creds.spotify_access_token || '';\n\nif (!token) return { json: { error: `Spotify ${i18n.not_connected}`, help: i18n.configure } };\nconst headers = { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' };\n\ntry {\n  if (action === 'now_playing') {\n    const res = await fetch('https://api.spotify.com/v1/me/player', { headers });\n    if (res.status === 204) return { json: { status: 'nothing playing' } };\n    const d = await res.json();\n    return { json: { is_playing: d.is_playing, track: d.item?.name, artist: d.item?.artists?.[0]?.name, album: d.item?.album?.name, progress_ms: d.progress_ms, duration_ms: d.item?.duration_ms, device: d.device?.name } };\n  }\n\n  if (action === 'pause') {\n    await fetch('https://api.spotify.com/v1/me/player/pause', { method: 'PUT', headers });\n    return { json: { success: true, message: i18n.success, action: 'paused' } };\n  }\n\n  if (action === 'resume' || (action === 'play' && !input.query && !input.uri)) {\n    await fetch('https://api.spotify.com/v1/me/player/play', { method: 'PUT', headers });\n    return { json: { success: true, message: i18n.success, action: 'resumed' } };\n  }\n\n  if (action === 'next') {\n    await fetch('https://api.spotify.com/v1/me/player/next', { method: 'POST', headers });\n    return { json: { success: true, message: i18n.success, action: 'next track' } };\n  }\n\n  if (action === 'prev') {\n    await fetch('https://api.spotify.com/v1/me/player/previous', { method: 'POST', headers });\n    return { json: { success: true, message: i18n.success, action: 'previous track' } };\n  }\n\n  if (action === 'set_volume') {\n    const vol = Math.min(100, Math.max(0, parseInt(input.volume_pct || 50)));\n    await fetch(`https://api.spotify.com/v1/me/player/volume?volume_percent=${vol}`, { method: 'PUT', headers });\n    return { json: { success: true, message: i18n.success, volume_pct: vol } };\n  }\n\n  if (action === 'set_shuffle') {\n    await fetch(`https://api.spotify.com/v1/me/player/shuffle?state=${input.enabled !== false}`, { method: 'PUT', headers });\n    return { json: { success: true, message: i18n.success, shuffle: input.enabled !== false } };\n  }\n\n  if (action === 'search') {\n    if (!input.query) return { json: { error: i18n.query_required || 'query required for search' } };\n    const type = input.type || 'track,playlist,artist';\n    const res = await fetch(`https://api.spotify.com/v1/search?q=${encodeURIComponent(input.query)}&type=${type}&limit=5&market=TH`, { headers });\n    const d = await res.json();\n    const results = {};\n    if (d.tracks) results.tracks = d.tracks.items.map(t => ({ name: t.name, artist: t.artists[0]?.name, uri: t.uri }));\n    if (d.playlists) results.playlists = d.playlists.items.map(p => ({ name: p.name, tracks: p.tracks?.total, uri: p.uri }));\n    if (d.artists) results.artists = d.artists.items.map(a => ({ name: a.name, uri: a.uri }));\n    return { json: { query: input.query, results } };\n  }\n\n  if (action === 'play' && (input.query || input.uri)) {\n    let uri = input.uri;\n    if (!uri && input.query) {\n      const sRes = await fetch(`https://api.spotify.com/v1/search?q=${encodeURIComponent(input.query)}&type=track,playlist&limit=1&market=TH`, { headers });\n      const sData = await sRes.json();\n      uri = sData.tracks?.items?.[0]?.uri || sData.playlists?.items?.[0]?.uri;\n      if (!uri) return { json: { error: `Nothing found for: ${input.query}` } };\n    }\n    const isContext = uri.includes(':album:') || uri.includes(':playlist:') || uri.includes(':artist:');\n    const body = isContext ? { context_uri: uri } : { uris: [uri] };\n    await fetch('https://api.spotify.com/v1/me/player/play', { method: 'PUT', headers, body: JSON.stringify(body) });\n    return { json: { success: true, message: i18n.success, playing: uri } };\n  }\n\n  if (action === 'list_devices') {\n    const res = await fetch('https://api.spotify.com/v1/me/player/devices', { headers });\n    const d = await res.json();\n    return { json: { devices: (d.devices || []).map(dev => ({ id: dev.id, name: dev.name, type: dev.type, is_active: dev.is_active, volume_pct: dev.volume_percent })) } };\n  }\n\n  if (action === 'create_playlist') {\n    if (!input.name) return { json: { error: i18n.name_required || 'name required' } };\n    const meRes = await fetch('https://api.spotify.com/v1/me', { headers });\n    const me = await meRes.json();\n    const res = await fetch(`https://api.spotify.com/v1/users/${me.id}/playlists`, { method: 'POST', headers, body: JSON.stringify({ name: input.name, description: input.description || '', public: false }) });\n    const d = await res.json();\n    return { json: { success: true, message: i18n.success, playlist_id: d.id, name: d.name, url: d.external_urls?.spotify } };\n  }\n\n  return { json: { error: `Unknown action: ${action}` } };\n} catch(e) {\n  return { json: { error: e.message } };\n}"
      },
      "id": "0e7900a2-81fa-4e20-bd55-674072ccb33c",
      "name": "control_spotify1",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        1936,
        464
      ]
    },
    {
      "parameters": {
        "name": "control_sonos",
        "description": "Control Sonos speakers. action: list_rooms, play, pause, set_volume (requires: room, volume 0-100), play_spotify (requires: room, spotify_uri), pause_all, resume_all, now_playing (requires: room).",
        "jsCode": "const input = JSON.parse($input.first().json.query || '{}');\nconst ctx = $('Load Credentials').first().json;\nconst creds = ctx.credentials || {};\nconst i18n = ctx.i18n || {};\nconst action = (input.action || 'list_rooms').toLowerCase();\nconst sonosBase = creds.sonos_api_url || process.env.SONOS_HTTP_API_URL || 'http://sonos-api:5005';\n\ntry {\n  const call = async (path) => {\n    const res = await fetch(`${sonosBase}${path}`);\n    if (!res.ok) throw new Error(`Sonos HTTP ${res.status}: ${path}`);\n    try { return await res.json(); } catch { return { ok: true }; }\n  };\n\n  if (action === 'list_rooms') {\n    const data = await call('/zones');\n    const rooms = (data || []).flatMap(z => z.members?.map(m => ({ room: m.roomName, uuid: m.uuid, state: m.state?.playbackState })) || []);\n    return { json: { rooms, count: rooms.length } };\n  }\n\n  if (action === 'pause_all') {\n    await call('/pauseAll');\n    return { json: { success: true, message: i18n.success, action: 'paused all rooms' } };\n  }\n\n  if (action === 'resume_all') {\n    await call('/resumeAll');\n    return { json: { success: true, message: i18n.success, action: 'resumed all rooms' } };\n  }\n\n  const room = input.room;\n  if (!room && !['pause_all','resume_all','list_rooms'].includes(action)) {\n    return { json: { error: i18n.room_required || 'room name required for this action' } };\n  }\n  const r = encodeURIComponent(room);\n\n  if (action === 'play') { await call(`/${r}/play`); return { json: { success: true, message: i18n.success, room, action: 'play' } }; }\n  if (action === 'pause') { await call(`/${r}/pause`); return { json: { success: true, message: i18n.success, room, action: 'pause' } }; }\n  if (action === 'now_playing') { const d = await call(`/${r}/state`); return { json: { room, ...d } }; }\n\n  if (action === 'set_volume') {\n    const vol = Math.min(100, Math.max(0, parseInt(input.volume || 50)));\n    await call(`/${r}/volume/${vol}`);\n    return { json: { success: true, message: i18n.success, room, volume: vol } };\n  }\n\n  if (action === 'play_spotify') {\n    if (!input.spotify_uri) return { json: { error: 'spotify_uri required' } };\n    await call(`/${r}/spotify/now/${encodeURIComponent(input.spotify_uri)}`);\n    return { json: { success: true, message: i18n.success, room, spotify_uri: input.spotify_uri } };\n  }\n\n  return { json: { error: `Unknown action: ${action}` } };\n} catch(e) {\n  return { json: { error: e.message, note: i18n.sonos_note || 'Is node-sonos-http-api running?' } };\n}"
      },
      "id": "57d8dee6-fe01-4853-a7d5-a96e369c8345",
      "name": "control_sonos1",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        2128,
        464
      ]
    },
    {
      "parameters": {
        "name": "control_home",
        "description": "Control smart home devices and set ambient modes. action: lights_on, lights_off, set_lights (requires: entity_id, optional: brightness_pct, kelvin), get_states, call_service (requires: domain, service, entity_id), set_ambient_mode (requires: mode: morning|work|relax|sleep|movie|study).",
        "jsCode": "const input = JSON.parse($input.first().json.query || '{}');\nconst ctx = $('Load Credentials').first().json;\nconst creds = ctx.credentials || {};\nconst i18n = ctx.i18n || {};\nconst lang = ctx.lang || 'th';\nconst action = (input.action || 'get_states').toLowerCase();\nconst haUrl = creds.ha_url || '';\nconst haToken = creds.ha_token || '';\n\nif (!haUrl || !haToken) return { json: { error: `Home Assistant ${i18n.not_connected}`, help: i18n.configure } };\nconst haHeaders = { 'Authorization': `Bearer ${haToken}`, 'Content-Type': 'application/json' };\n\n// Multilingual ambient mode descriptions\nconst ambientDescriptions = {\n  morning: { th: 'เช้า: แสงสว่าง 5000K + เพลง energetic', en: 'Morning: Bright 5000K light + energetic music', ja: '朝: 明るい5000K照明 + エネルギッシュな音楽', zh: '早晨：明亮5000K灯光 + 充沛活力音乐' },\n  work:    { th: 'ทำงาน: แสง neutral 4000K + lo-fi', en: 'Work: Neutral 4000K light + lo-fi music', ja: '作業: ニュートラル4000K照明 + ローファイ音楽', zh: '工作：中性4000K灯光 + lo-fi音乐' },\n  relax:   { th: 'ผ่อนคลาย: แสงอุ่น 40% + chill', en: 'Relax: Warm 40% light + chill music', ja: 'リラックス: 暖かい40%照明 + チル音楽', zh: '放松：温暖40%灯光 + 轻松音乐' },\n  sleep:   { th: 'นอน: ไฟดับ + เสียงธรรมชาติ', en: 'Sleep: Lights off + nature sounds', ja: '睡眠: 消灯 + 自然の音', zh: '睡眠：关灯 + 自然声音' },\n  movie:   { th: 'ดูหนัง: แสงริมๆ + ไม่มีเพลง', en: 'Movie: Dim ambient light + no music', ja: '映画: 薄暗い照明 + 音楽なし', zh: '电影：昏暗灯光 + 无音乐' },\n  study:   { th: 'อ่านหนังสือ: แสงจ้า 6000K + classical', en: 'Study: Bright 6000K light + classical music', ja: '勉強: 明るい6000K照明 + クラシック音楽', zh: '学习：明亮6000K灯光 + 古典音乐' }\n};\n\nconst localLang = ['th','en','ja','zh'].includes(lang) ? lang : 'en';\n\nconst ambientModes = {\n  morning: { lights: { entity_id: 'all', brightness_pct: 80, kelvin: 5000 }, spotify_query: 'morning energy playlist' },\n  work:    { lights: { entity_id: 'all', brightness_pct: 100, kelvin: 4000 }, spotify_query: 'lo-fi hip hop focus' },\n  relax:   { lights: { entity_id: 'all', brightness_pct: 40, kelvin: 2700 }, spotify_query: 'thai chill acoustic' },\n  sleep:   { lights: { entity_id: 'all', service: 'turn_off' }, spotify_query: 'sleep sounds rain' },\n  movie:   { lights: { entity_id: 'all', brightness_pct: 8, kelvin: 2200 }, spotify_query: null },\n  study:   { lights: { entity_id: 'all', brightness_pct: 100, kelvin: 6000 }, spotify_query: 'classical concentration' }\n};\n\ntry {\n  if (action === 'set_ambient_mode') {\n    const mode = (input.mode || 'relax').toLowerCase();\n    const preset = ambientModes[mode];\n    if (!preset) return { json: { error: `Unknown mode: ${mode}`, available: Object.keys(ambientModes) } };\n\n    const lightSvc = preset.lights.service === 'turn_off' ? 'turn_off' : 'turn_on';\n    const lightData = { entity_id: preset.lights.entity_id };\n    if (preset.lights.brightness_pct) lightData.brightness_pct = preset.lights.brightness_pct;\n    if (preset.lights.kelvin) lightData.color_temp_kelvin = preset.lights.kelvin;\n    await fetch(`${haUrl}/api/services/light/${lightSvc}`, { method: 'POST', headers: haHeaders, body: JSON.stringify(lightData) });\n\n    // Description in user's language\n    const description = ambientDescriptions[mode]?.[localLang] || ambientDescriptions[mode]?.['en'] || mode;\n    return { json: { success: true, message: i18n.success, mode, description, spotify_suggestion: preset.spotify_query } };\n  }\n\n  if (action === 'get_states') {\n    const res = await fetch(`${haUrl}/api/states`, { headers: haHeaders });\n    const states = await res.json();\n    const relevant = (states || []).filter(s => ['light','switch','climate','sensor'].some(d => s.entity_id.startsWith(d))).slice(0, 20).map(s => ({ entity_id: s.entity_id, state: s.state, friendly_name: s.attributes?.friendly_name }));\n    return { json: { devices: relevant, count: relevant.length } };\n  }\n\n  if (action === 'lights_on') {\n    const entityId = input.entity_id || 'all';\n    await fetch(`${haUrl}/api/services/light/turn_on`, { method: 'POST', headers: haHeaders, body: JSON.stringify({ entity_id: entityId }) });\n    return { json: { success: true, message: i18n.success, action: 'lights on', entity_id: entityId } };\n  }\n\n  if (action === 'lights_off') {\n    const entityId = input.entity_id || 'all';\n    await fetch(`${haUrl}/api/services/light/turn_off`, { method: 'POST', headers: haHeaders, body: JSON.stringify({ entity_id: entityId }) });\n    return { json: { success: true, message: i18n.success, action: 'lights off', entity_id: entityId } };\n  }\n\n  if (action === 'set_lights') {\n    const entityId = input.entity_id || 'all';\n    const data = { entity_id: entityId };\n    if (input.brightness_pct !== undefined) data.brightness_pct = Math.min(100, Math.max(0, parseInt(input.brightness_pct)));\n    if (input.kelvin !== undefined) data.color_temp_kelvin = Math.min(6500, Math.max(2700, parseInt(input.kelvin)));\n    await fetch(`${haUrl}/api/services/light/turn_on`, { method: 'POST', headers: haHeaders, body: JSON.stringify(data) });\n    return { json: { success: true, message: i18n.success, entity_id: entityId, ...data } };\n  }\n\n  if (action === 'call_service') {\n    const { domain, service, entity_id, service_data } = input;\n    if (!domain || !service) return { json: { error: 'domain and service required' } };\n    const body = { entity_id, ...(service_data || {}) };\n    await fetch(`${haUrl}/api/services/${domain}/${service}`, { method: 'POST', headers: haHeaders, body: JSON.stringify(body) });\n    return { json: { success: true, message: i18n.success, called: `${domain}.${service}`, entity_id } };\n  }\n\n  return { json: { error: `Unknown action: ${action}` } };\n} catch(e) {\n  return { json: { error: e.message } };\n}"
      },
      "id": "5f1c60ea-3693-4fcf-8e3d-d2a5e9ce2473",
      "name": "control_home1",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        2304,
        464
      ]
    },
    {
      "parameters": {
        "name": "music_lookup",
        "description": "Apple Music logging via Last.fm and YouTube Music search. lookup_type: scrobble_track (requires: artist, track), recent_tracks, top_tracks (optional: period 7day|1month|3month), youtube_music_search (requires: query).",
        "jsCode": "const input = JSON.parse($input.first().json.query || '{}');\nconst ctx = $('Load Credentials').first().json;\nconst creds = ctx.credentials || {};\nconst i18n = ctx.i18n || {};\nconst lookupType = (input.lookup_type || 'recent_tracks').toLowerCase();\nconst lfKey = creds.lastfm_api_key || '';\nconst lfUser = creds.lastfm_username || '';\nconst lfSk = creds.lastfm_session_key || '';\nconst ytKey = creds.youtube_api_key || '';\n\ntry {\n  if (lookupType === 'youtube_music_search') {\n    if (!input.query) return { json: { error: i18n.query_required || 'query required' } };\n    if (!ytKey) return { json: { error: `YouTube API key ${i18n.not_connected}`, help: i18n.configure } };\n    const res = await fetch(`https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(input.query + ' official audio')}&type=video&videoCategoryId=10&maxResults=5&key=${ytKey}`);\n    const data = await res.json();\n    if (data.error) return { json: { error: data.error.message } };\n    // FIXED: youtube_note now uses i18n\n    return { json: {\n      results: (data.items || []).map(v => ({\n        title: v.snippet.title,\n        channel: v.snippet.channelTitle,\n        url: `https://youtube.com/watch?v=${v.id.videoId}`\n      })),\n      note: i18n.youtube_note\n    }};\n  }\n\n  if (!lfKey) return { json: { error: `Last.fm API key ${i18n.not_connected}`, help: i18n.configure } };\n\n  if (lookupType === 'scrobble_track') {\n    if (!input.artist || !input.track) return { json: { error: 'artist and track required' } };\n    if (!lfSk) return { json: { error: 'Last.fm session key not configured (need auth)', help: i18n.configure } };\n    return { json: {\n      info: `Scrobbled: ${input.artist} - ${input.track}`,\n      note: 'Full scrobble requires Last.fm HMAC auth — configure lastfm_session_key in persona',\n      artist: input.artist,\n      track: input.track\n    }};\n  }\n\n  if (lookupType === 'recent_tracks') {\n    if (!lfUser) return { json: { error: 'lastfm_username not configured', help: i18n.configure } };\n    const res = await fetch(`https://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks&user=${lfUser}&api_key=${lfKey}&limit=10&format=json`);\n    const data = await res.json();\n    if (data.error) return { json: { error: data.message } };\n    const tracks = (data.recenttracks?.track || []).map(t => ({\n      artist: t.artist?.['#text'],\n      track: t.name,\n      album: t.album?.['#text'],\n      now_playing: t['@attr']?.nowplaying === 'true'\n    }));\n    return { json: { tracks, count: tracks.length } };\n  }\n\n  if (lookupType === 'top_tracks') {\n    if (!lfUser) return { json: { error: 'lastfm_username not configured', help: i18n.configure } };\n    const period = input.period || '1month';\n    const res = await fetch(`https://ws.audioscrobbler.com/2.0/?method=user.gettoptracks&user=${lfUser}&api_key=${lfKey}&period=${period}&limit=10&format=json`);\n    const data = await res.json();\n    if (data.error) return { json: { error: data.message } };\n    const tracks = (data.toptracks?.track || []).map(t => ({\n      rank: t['@attr']?.rank,\n      artist: t.artist?.name,\n      track: t.name,\n      playcount: t.playcount\n    }));\n    return { json: { tracks, period, count: tracks.length } };\n  }\n\n  return { json: { error: `Unknown lookup_type: ${lookupType}. Use: scrobble_track, recent_tracks, top_tracks, youtube_music_search` } };\n} catch(e) {\n  return { json: { error: e.message } };\n}"
      },
      "id": "d955b345-6768-4a08-b144-1040068bcdcb",
      "name": "music_lookup1",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        2480,
        464
      ]
    },
    {
      "parameters": {
        "jsCode": "const out = $input.first().json.output || $input.first().json.text || 'ดำเนินการแล้วครับ';\nconst prev = $('Extract Payload1').item.json;\nreturn { json: { ...prev, agentOutput: out, agentCategory: 'home-mate', processedAt: new Date().toISOString() } };"
      },
      "id": "7c21c15d-4062-456b-98a9-792489dcd3b7",
      "name": "Format Output1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2688,
        224
      ]
    },
    {
      "parameters": {
        "model": "anthropic/claude-haiku-4.5",
        "options": {
          "maxTokens": 2500
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        1408,
        464
      ],
      "id": "f1f0f90e-0736-4e74-81d6-3d877b0d3fa9",
      "name": "OpenRouter Chat Model (Haiku)",
      "credentials": {
        "openRouterApi": {
          "id": "FUm3Fg9B8euy8cH3",
          "name": "OpenRouter - 2026-02-14T03:30"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "WF3-F Entry1": {
      "main": [
        [
          {
            "node": "Extract Payload1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Payload1": {
      "main": [
        [
          {
            "node": "Load Credentials",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Credentials": {
      "main": [
        [
          {
            "node": "Home Mate Agent1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Home Mate Agent1": {
      "main": [
        [
          {
            "node": "Format Output1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Session Memory1": {
      "ai_memory": [
        [
          {
            "node": "Home Mate Agent1",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "think1": {
      "ai_tool": [
        [
          {
            "node": "Home Mate Agent1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "control_spotify1": {
      "ai_tool": [
        [
          {
            "node": "Home Mate Agent1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "control_sonos1": {
      "ai_tool": [
        [
          {
            "node": "Home Mate Agent1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "control_home1": {
      "ai_tool": [
        [
          {
            "node": "Home Mate Agent1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "music_lookup1": {
      "ai_tool": [
        [
          {
            "node": "Home Mate Agent1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model (Haiku)": {
      "ai_languageModel": [
        [
          {
            "node": "Home Mate Agent1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "binaryMode": "separate",
    "availableInMCP": false
  },
  "versionId": "161151ef-b471-4cd7-b6e8-069186bafbc9",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "c3a8077648ce894608db1ade94831096370fb6a0453430d193f6c81b3c8cc1cb"
  },
  "id": "NqBehKrMuLynNmwO",
  "tags": []
}
