{
  "name": "WF3-A — Secretary Agent v3 (Code Tool approach)",
  "nodes": [
    {
      "parameters": {
        "content": "# WF3-A — SECRETARY v3\n\n## Architecture: Code Tool\nแทน 21 tools → 6 tools\nLLM เห็น tool name ชัดเจน\nCode ภายใน route ไป API ถูกต้อง\n\n## 6 Tools:\n1. manage_calendar  → GCal create/list\n2. manage_tasks     → GTasks create/list\n3. manage_email     → Gmail + Outlook + IMAP\n4. manage_chat      → Telegram + Discord + Slack\n5. manage_social    → Twitter + YouTube\n6. think            → Think Tool\n\n## MULTILINGUAL SUPPORT:\n- th / en / ja / zh\n- i18n via Load Credentials node\n- Dynamic error messages per language",
        "height": 400,
        "width": 380,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -192,
        -48
      ],
      "id": "01a775f4-d3e7-4417-87ec-42621fde631f",
      "name": "Secretary v3 Overview"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "wf3a-secretary",
        "responseMode": "lastNode",
        "options": {}
      },
      "id": "230abb45-21e8-4d6a-9c02-23143ad491aa",
      "name": "WF3-A Entry",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        672,
        304
      ],
      "webhookId": "wf3a-secretary-entry"
    },
    {
      "parameters": {
        "jsCode": "const payload = $input.first().json.body || $input.first().json;\nreturn {\n  json: {\n    userId: payload.userId,\n    sessionId: payload.sessionId,\n    source: payload.source,\n    message: payload.message || payload.enrichedMessage,\n    originalMessage: payload.originalMessage || payload.message,\n    persona: typeof payload.persona === 'string' ? JSON.parse(payload.persona) : (payload.persona || {}),\n    replyTarget: payload.replyTarget,\n    replyToken: payload.replyToken,\n    timestamp: payload.timestamp,\n    connectedServices: payload.connectedServices || []\n  }\n};"
      },
      "id": "9bde8079-4275-47d3-b375-d400d832713d",
      "name": "Extract Payload",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        960,
        304
      ]
    },
    {
      "parameters": {
        "jsCode": "// Load Credentials — MULTILINGUAL + i18n\nconst prev = $('Extract Payload').first().json;\nconst p = prev.persona || {};\nconst t = p.tokens || {};\nconst lang = p.language_preference || 'th';\n\n// i18n Messages\nconst i18nMap = {\n  th: {\n    not_connected: 'ยังไม่ได้เชื่อมต่อ',\n    configure: 'กรุณาตั้งค่าที่ /dashboard/api-settings',\n    success: 'สำเร็จ',\n    error: 'เกิดข้อผิดพลาด',\n    completed: 'เสร็จแล้ว'\n  },\n  en: {\n    not_connected: 'Not connected',\n    configure: 'Please configure at /dashboard/api-settings',\n    success: 'Success',\n    error: 'Error occurred',\n    completed: 'Completed'\n  },\n  ja: {\n    not_connected: '接続されていません',\n    configure: '/dashboard/api-settingsで設定してください',\n    success: '成功しました',\n    error: 'エラーが発生しました',\n    completed: '完了しました'\n  },\n  zh: {\n    not_connected: '未连接',\n    configure: '请在 /dashboard/api-settings 配置',\n    success: '成功',\n    error: '发生错误',\n    completed: '已完成'\n  }\n};\n\nconst i18n = i18nMap[lang] || i18nMap['en'];\n\nconst get = (envKey, payloadKey) =>\n  t[payloadKey] || p[payloadKey] || process.env[envKey] || '';\n\nconst creds = {\n  google_access_token:    get('GOOGLE_ACCESS_TOKEN',    'google_access_token'),\n  google_refresh_token:   get('GOOGLE_REFRESH_TOKEN',   'google_refresh_token'),\n  microsoft_access_token: get('MICROSOFT_ACCESS_TOKEN', 'microsoft_access_token'),\n  outlook_access_token:   get('MICROSOFT_ACCESS_TOKEN', 'microsoft_access_token'),\n  telegram_bot_token:     get('TELEGRAM_BOT_TOKEN',     'telegram_bot_token'),\n  discord_bot_token:      get('DISCORD_BOT_TOKEN',      'discord_bot_token'),\n  slack_bot_token:        get('SLACK_BOT_TOKEN',        'slack_bot_token'),\n  twitter_bearer_token:   get('TWITTER_BEARER_TOKEN',   'twitter_bearer_token'),\n  facebook_access_token:  get('FACEBOOK_ACCESS_TOKEN',  'facebook_access_token'),\n  linkedin_access_token:  get('LINKEDIN_ACCESS_TOKEN',  'linkedin_access_token'),\n  spotify_access_token:   get('SPOTIFY_ACCESS_TOKEN',   'spotify_access_token'),\n  youtube_api_key:        get('YOUTUBE_API_KEY',        'youtube_api_key'),\n  line_notify_token:      get('LINE_NOTIFY_TOKEN',      'line_notify_token'),\n  google_maps_key:        get('GOOGLE_MAPS_API_KEY',    'google_maps_key'),\n  brave_api_key:          get('BRAVE_API_KEY',          'brave_api_key'),\n  openweathermap_key:     get('OPENWEATHERMAP_API_KEY', 'openweathermap_key'),\n  fal_api_key:            get('FAL_API_KEY',            'fal_api_key'),\n  elevenlabs_api_key:     get('ELEVENLABS_API_KEY',     'elevenlabs_api_key'),\n  unsplash_access_key:    get('UNSPLASH_ACCESS_KEY',    'unsplash_access_key'),\n  nutritionix_app_id:     get('NUTRITIONIX_APP_ID',     'nutritionix_app_id'),\n  nutritionix_api_key:    get('NUTRITIONIX_API_KEY',    'nutritionix_api_key'),\n  finnhub_api_key:        get('FINNHUB_API_KEY',        'finnhub_api_key'),\n  ha_url:                 get('HOME_ASSISTANT_URL',      'ha_url'),\n  ha_token:               get('HOME_ASSISTANT_TOKEN',    'ha_token'),\n  sonos_api_url:          get('SONOS_HTTP_API_URL',     'sonos_api_url'),\n  lastfm_api_key:         get('LASTFM_API_KEY',         'lastfm_api_key'),\n  gating_service_url:     get('GATING_SERVICE_URL',     'gating_service_url'),\n  internal_auth_token:    get('INTERNAL_AUTH_TOKEN',    'internal_auth_token'),\n  n8n_base_url:           get('N8N_BASE_URL',           'n8n_base_url'),\n  database_url:           get('DATABASE_URL',           'database_url'),\n};\n\nconst connected = Object.entries(creds).filter(([k,v]) => v).map(([k]) => k);\n\nconsole.log('[Load Credentials]', {\n  userId: prev.userId?.substring(0, 8) + '...',\n  connected: connected.length,\n  lang\n});\n\nreturn { \n  json: { \n    ...prev, \n    credentials: creds, \n    lang,\n    i18n,\n    _connected: connected \n  } \n};"
      },
      "id": "d44a62c1-ef97-4bf1-84ee-4bcfadcdb6d8",
      "name": "Load Credentials",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1216,
        304
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.message }}",
        "options": {
          "systemMessage": "=You are Sunday's Secretary — a world-class personal assistant.\n\nUser: {{ $json.persona.name || 'User' }}\nLanguage: {{ $json.persona.language_preference || 'th' }}\nTime: {{ $json.timestamp }}\n\n## LANGUAGE RULES:\n**ALWAYS respond in user's preferred language: {{ $json.persona.language_preference }}**\n- If 'th' → Thai\n- If 'en' → English  \n- If 'ja' → Japanese\n- If 'zh' → Chinese\n\n## TOOLS:\nmanage_calendar, manage_tasks, manage_email, manage_chat, manage_social, send_line_notification, think\n\n## RULES:\n- Confirm before sending important messages\n- If service not connected → inform in user's language\n- **Never force Thai when user prefers another language**"
        }
      },
      "id": "a5602df0-3408-4480-b2a4-e97e938170f8",
      "name": "Secretary Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.8,
      "position": [
        1472,
        192
      ]
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $('Load Credentials').item.json.sessionId }}"
      },
      "id": "71a3bbbf-d5d1-427a-a393-2dc1268fb6f6",
      "name": "Session Memory",
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        1456,
        432
      ]
    },
    {
      "parameters": {},
      "id": "29a21e1e-ba04-42fc-b781-36ad5a8fa1d3",
      "name": "think",
      "type": "@n8n/n8n-nodes-langchain.toolThink",
      "typeVersion": 1,
      "position": [
        1600,
        432
      ]
    },
    {
      "parameters": {
        "name": "manage_calendar",
        "description": "Create or read Google Calendar events. Actions: create_event, list_events, find_free_slots.",
        "jsCode": "// manage_calendar\n// Expected input: { action, title, start, end, description, location, time_min, time_max }\nconst input = JSON.parse($input.first().json.query || '{}');\nconst creds = $('Load Credentials').first().json.credentials || {};\nconst i18n = $('Load Credentials').first().json.i18n || {};\nconst action = (input.action || 'list_events').toLowerCase();\nconst persona = $('Load Credentials').first().json.persona;\n\n// Build Google Calendar API request\nconst baseUrl = 'https://www.googleapis.com/calendar/v3';\nconst token = creds.google_access_token || persona.google_access_token || '';\n\nif (!token) {\n  return { json: { error: `Google Calendar ${i18n.not_connected}`, help: i18n.configure, action } };\n}\n\nlet url, method, body;\n\nif (action === 'create_event') {\n  url = `${baseUrl}/calendars/primary/events`;\n  method = 'POST';\n  body = JSON.stringify({\n    summary: input.title || '',\n    description: input.description || '',\n    location: input.location || '',\n    start: { dateTime: input.start, timeZone: 'Asia/Bangkok' },\n    end: { dateTime: input.end, timeZone: 'Asia/Bangkok' }\n  });\n} else {\n  // list_events\n  const timeMin = input.time_min || new Date().toISOString();\n  const timeMax = input.time_max || new Date(Date.now() + 7*24*60*60*1000).toISOString();\n  url = `${baseUrl}/calendars/primary/events?timeMin=${encodeURIComponent(timeMin)}&timeMax=${encodeURIComponent(timeMax)}&singleEvents=true&orderBy=startTime&maxResults=20`;\n  method = 'GET';\n  body = null;\n}\n\nconst response = await fetch(url, {\n  method,\n  headers: {\n    'Authorization': `Bearer ${token}`,\n    'Content-Type': 'application/json'\n  },\n  body: body || undefined\n});\n\nconst data = await response.json();\n\nif (!response.ok) {\n  return { json: { error: data.error?.message || `Calendar API ${i18n.error}`, status: response.status } };\n}\n\nif (action === 'create_event') {\n  return { json: { success: true, message: i18n.success, event_id: data.id, title: data.summary, start: data.start, link: data.htmlLink } };\n}\n\n// Format list\nconst events = (data.items || []).map(e => ({\n  id: e.id,\n  title: e.summary,\n  start: e.start?.dateTime || e.start?.date,\n  end: e.end?.dateTime || e.end?.date,\n  location: e.location || ''\n}));\n\nreturn { json: { events, count: events.length } };"
      },
      "id": "5e2a3ea4-0bbb-4239-a69b-d58fe4ddaf8c",
      "name": "manage_calendar",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        1744,
        432
      ]
    },
    {
      "parameters": {
        "name": "manage_tasks",
        "description": "Create or read Google Tasks. Actions: create_task, list_tasks, complete_task.",
        "jsCode": "// manage_tasks\nconst input = JSON.parse($input.first().json.query || '{}');\nconst action = (input.action || 'list_tasks').toLowerCase();\nconst creds = $('Load Credentials').first().json.credentials || {};\nconst i18n = $('Load Credentials').first().json.i18n || {};\nconst persona = $('Load Credentials').first().json.persona;\nconst token = creds.google_access_token || persona.google_access_token || '';\n\nif (!token) {\n  return { json: { error: `Google Tasks ${i18n.not_connected}`, help: i18n.configure } };\n}\n\nconst baseUrl = 'https://tasks.googleapis.com/tasks/v1';\nlet url, method, body;\n\nif (action === 'create_task') {\n  url = `${baseUrl}/lists/@default/tasks`;\n  method = 'POST';\n  body = JSON.stringify({\n    title: input.title || '',\n    notes: input.notes || '',\n    due: input.due || null\n  });\n} else if (action === 'complete_task') {\n  url = `${baseUrl}/lists/@default/tasks/${input.task_id}`;\n  method = 'PATCH';\n  body = JSON.stringify({ status: 'completed' });\n} else {\n  url = `${baseUrl}/lists/@default/tasks?showCompleted=false&maxResults=20`;\n  method = 'GET';\n  body = null;\n}\n\nconst response = await fetch(url, {\n  method,\n  headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },\n  body: body || undefined\n});\n\nconst data = await response.json();\n\nif (!response.ok) {\n  return { json: { error: data.error?.message || `Tasks API ${i18n.error}` } };\n}\n\nif (action === 'list_tasks') {\n  const tasks = (data.items || []).map(t => ({ id: t.id, title: t.title, due: t.due, status: t.status }));\n  return { json: { tasks, count: tasks.length } };\n}\n\nreturn { json: { success: true, message: i18n.success, task: { id: data.id, title: data.title, status: data.status } } };"
      },
      "id": "9f769299-7952-47d3-9f7f-d7be6bc074bc",
      "name": "manage_tasks",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        1920,
        432
      ]
    },
    {
      "parameters": {
        "name": "manage_email",
        "description": "Read or send email. Providers: gmail (default), outlook, imap. Actions: read_inbox, send_email, search_email.",
        "jsCode": "// manage_email\n// input: { action, provider, to, subject, body, query, max_results }\nconst input = JSON.parse($input.first().json.query || '{}');\nconst creds = $('Load Credentials').first().json.credentials || {};\nconst i18n = $('Load Credentials').first().json.i18n || {};\nconst action = (input.action || 'read_inbox').toLowerCase();\nconst provider = (input.provider || 'gmail').toLowerCase();\nconst persona = $('Load Credentials').first().json.persona;\n\n// ── GMAIL ──────────────────────────────────────────────\nif (provider === 'gmail') {\n  const token = creds.google_access_token || persona.google_access_token || '';\n  if (!token) return { json: { error: `Gmail ${i18n.not_connected}`, help: i18n.configure } };\n\n  if (action === 'send_email') {\n    const raw = btoa(`To: ${input.to}\\nSubject: ${input.subject}\\nContent-Type: text/plain; charset=utf-8\\n\\n${input.body}`)\n      .replace(/\\+/g,'-').replace(/\\//g,'_').replace(/=+$/,'');\n    const res = await fetch('https://gmail.googleapis.com/gmail/v1/users/me/messages/send', {\n      method: 'POST',\n      headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },\n      body: JSON.stringify({ raw })\n    });\n    const data = await res.json();\n    if (!res.ok) return { json: { error: data.error?.message || i18n.error } };\n    return { json: { success: true, message: i18n.success, message_id: data.id, provider: 'gmail' } };\n  }\n\n  // read_inbox / search\n  const q = input.query || 'is:unread';\n  const maxResults = input.max_results || 10;\n  const listRes = await fetch(`https://gmail.googleapis.com/gmail/v1/users/me/messages?q=${encodeURIComponent(q)}&maxResults=${maxResults}`, {\n    headers: { 'Authorization': `Bearer ${token}` }\n  });\n  const listData = await listRes.json();\n  const messages = (listData.messages || []).slice(0, 5);\n\n  const details = await Promise.all(messages.map(async m => {\n    const r = await fetch(`https://gmail.googleapis.com/gmail/v1/users/me/messages/${m.id}?format=metadata&metadataHeaders=Subject&metadataHeaders=From`, {\n      headers: { 'Authorization': `Bearer ${token}` }\n    });\n    const d = await r.json();\n    const headers = {};\n    (d.payload?.headers || []).forEach(h => { headers[h.name] = h.value; });\n    return { id: m.id, from: headers['From'], subject: headers['Subject'], snippet: d.snippet };\n  }));\n\n  return { json: { emails: details, count: details.length, provider: 'gmail' } };\n}\n\n// ── OUTLOOK (Microsoft Graph) ───────────────────────────\nif (provider === 'outlook') {\n  const token = creds.outlook_access_token || creds.microsoft_access_token || persona.outlook_access_token || '';\n  if (!token) return { json: { error: `Outlook ${i18n.not_connected}`, help: i18n.configure } };\n\n  if (action === 'send_email') {\n    const res = await fetch('https://graph.microsoft.com/v1.0/me/sendMail', {\n      method: 'POST',\n      headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        message: {\n          subject: input.subject,\n          body: { contentType: 'Text', content: input.body },\n          toRecipients: [{ emailAddress: { address: input.to } }]\n        }\n      })\n    });\n    if (res.status === 202) return { json: { success: true, message: i18n.success, provider: 'outlook' } };\n    const data = await res.json();\n    return { json: { error: data.error?.message || i18n.error } };\n  }\n\n  const filter = action === 'search_email'\n    ? `$search=\"${input.query || ''}\"`\n    : '$filter=isRead eq false';\n  const res = await fetch(`https://graph.microsoft.com/v1.0/me/messages?${filter}&$top=${input.max_results || 10}&$select=id,subject,from,receivedDateTime,bodyPreview`, {\n    headers: { 'Authorization': `Bearer ${token}` }\n  });\n  const data = await res.json();\n  const emails = (data.value || []).map(m => ({\n    id: m.id,\n    from: m.from?.emailAddress?.address,\n    subject: m.subject,\n    snippet: m.bodyPreview,\n    received: m.receivedDateTime\n  }));\n  return { json: { emails, count: emails.length, provider: 'outlook' } };\n}\n\n// ── IMAP ─────────────────────────────────────────────────\nreturn { json: { error: `IMAP ${i18n.not_connected} — use Gmail or Outlook`, provider: 'imap' } };"
      },
      "id": "c3174d69-d2ce-4efc-9182-6ffb9a92a1fc",
      "name": "manage_email",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        2112,
        432
      ]
    },
    {
      "parameters": {
        "name": "manage_chat",
        "description": "Send or read messages on chat platforms. Platforms: telegram, discord, slack. Actions: send_message, read_messages.",
        "jsCode": "// manage_chat\n// input: { action, platform, target, message, limit }\nconst input = JSON.parse($input.first().json.query || '{}');\nconst creds = $('Load Credentials').first().json.credentials || {};\nconst i18n = $('Load Credentials').first().json.i18n || {};\nconst action = (input.action || 'send_message').toLowerCase();\nconst platform = (input.platform || '').toLowerCase();\nconst persona = $('Load Credentials').first().json.persona;\n\n// ── TELEGRAM ────────────────────────────────────────────\nif (platform === 'telegram') {\n  const botToken = creds.telegram_bot_token || persona.telegram_bot_token || '';\n  if (!botToken) return { json: { error: `Telegram ${i18n.not_connected}`, help: i18n.configure } };\n\n  if (action === 'send_message') {\n    const res = await fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ chat_id: input.target, text: input.message, parse_mode: 'Markdown' })\n    });\n    const data = await res.json();\n    if (!data.ok) return { json: { error: data.description } };\n    return { json: { success: true, message_id: data.result?.message_id, platform: 'telegram' } };\n  }\n\n  const res = await fetch(`https://api.telegram.org/bot${botToken}/getUpdates?limit=${input.limit || 20}&offset=-${input.limit || 20}`);\n  const data = await res.json();\n  const msgs = (data.result || []).map(u => ({\n    from: u.message?.from?.username || u.message?.from?.first_name,\n    chat_id: u.message?.chat?.id,\n    text: u.message?.text,\n    date: new Date(u.message?.date * 1000).toISOString()\n  })).filter(m => m.text);\n  return { json: { messages: msgs, count: msgs.length, platform: 'telegram' } };\n}\n\n// ── DISCORD ──────────────────────────────────────────────\nif (platform === 'discord') {\n  const botToken = creds.discord_bot_token || persona.discord_bot_token || '';\n  if (!botToken) return { json: { error: `Discord ${i18n.not_connected}`, help: i18n.configure } };\n\n  if (action === 'send_message') {\n    const res = await fetch(`https://discord.com/api/v10/channels/${input.target}/messages`, {\n      method: 'POST',\n      headers: { 'Authorization': `Bot ${botToken}`, 'Content-Type': 'application/json' },\n      body: JSON.stringify({ content: input.message })\n    });\n    const data = await res.json();\n    if (data.code) return { json: { error: data.message } };\n    return { json: { success: true, message_id: data.id, platform: 'discord' } };\n  }\n\n  const res = await fetch(`https://discord.com/api/v10/channels/${input.target}/messages?limit=${input.limit || 20}`, {\n    headers: { 'Authorization': `Bot ${botToken}` }\n  });\n  const msgs = await res.json();\n  return { json: { messages: (msgs || []).map(m => ({ id: m.id, author: m.author?.username, content: m.content, timestamp: m.timestamp })), platform: 'discord' } };\n}\n\n// ── SLACK ────────────────────────────────────────────────\nif (platform === 'slack') {\n  const botToken = creds.slack_bot_token || persona.slack_bot_token || '';\n  if (!botToken) return { json: { error: `Slack ${i18n.not_connected}`, help: i18n.configure } };\n\n  if (action === 'send_message') {\n    const res = await fetch('https://slack.com/api/chat.postMessage', {\n      method: 'POST',\n      headers: { 'Authorization': `Bearer ${botToken}`, 'Content-Type': 'application/json' },\n      body: JSON.stringify({ channel: input.target, text: input.message })\n    });\n    const data = await res.json();\n    if (!data.ok) return { json: { error: data.error } };\n    return { json: { success: true, ts: data.ts, platform: 'slack' } };\n  }\n\n  const res = await fetch(`https://slack.com/api/conversations.history?channel=${input.target}&limit=${input.limit || 20}`, {\n    headers: { 'Authorization': `Bearer ${botToken}` }\n  });\n  const data = await res.json();\n  if (!data.ok) return { json: { error: data.error } };\n  return { json: { messages: (data.messages || []).map(m => ({ ts: m.ts, user: m.user, text: m.text })), platform: 'slack' } };\n}\n\nreturn { json: { error: `${i18n.error}: Unknown platform: ${platform}. Use: telegram, discord, slack` } };"
      },
      "id": "c2837099-32a2-4730-bc02-35c00ee7cbfa",
      "name": "manage_chat",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        2320,
        432
      ]
    },
    {
      "parameters": {
        "name": "manage_social",
        "description": "Post or read social media. Platforms: twitter, youtube, reddit, facebook, linkedin. Actions: post_tweet, search_tweets, get_feed, get_subscription_feed, get_channel_videos, get_timeline, post_facebook, post_linkedin, get_my_posts, search_reddit, get_feed_summary.",
        "jsCode": "// manage_social — MULTILINGUAL + EXPANDED WITH FEEDS\n// input: { action, platform, content, query, channel_id, subreddit, limit, filter, page_id }\nconst input = JSON.parse($input.first().json.query || '{}');\nconst creds = $('Load Credentials').first().json.credentials || {};\nconst i18n = $('Load Credentials').first().json.i18n || {};\nconst action = (input.action || '').toLowerCase();\nconst platform = (input.platform || '').toLowerCase();\nconst persona = $('Load Credentials').first().json.persona;\n\n// ══════════════════════════════════════════════════════════════\n// TWITTER / X\n// ══════════════════════════════════════════════════════════════\nif (platform === 'twitter' || platform === 'x') {\n  const bearerToken = creds.twitter_bearer_token || persona.twitter_bearer_token || '';\n  const accessToken = persona.twitter_access_token || '';\n\n  if (action === 'post_tweet') {\n    if (!accessToken) return { json: { error: `Twitter OAuth ${i18n.not_connected}`, help: i18n.configure } };\n    const text = (input.content || '').slice(0, 280);\n    const res = await fetch('https://api.twitter.com/2/tweets', {\n      method: 'POST',\n      headers: { 'Authorization': `Bearer ${accessToken}`, 'Content-Type': 'application/json' },\n      body: JSON.stringify({ text })\n    });\n    const data = await res.json();\n    if (data.errors) return { json: { error: data.errors[0]?.message } };\n    return { json: { success: true, message: i18n.success, tweet_id: data.data?.id, text: data.data?.text, platform: 'twitter' } };\n  }\n\n  if (action === 'search_tweets') {\n    if (!bearerToken) return { json: { error: `Twitter Bearer token ${i18n.not_connected}`, help: i18n.configure } };\n    const res = await fetch(`https://api.twitter.com/2/tweets/search/recent?query=${encodeURIComponent(input.query || '')}&max_results=${input.limit || 10}&tweet.fields=created_at,public_metrics`, {\n      headers: { 'Authorization': `Bearer ${bearerToken}` }\n    });\n    const data = await res.json();\n    return { json: { tweets: data.data || [], meta: data.meta, platform: 'twitter' } };\n  }\n\n  if (action === 'get_feed' || action === 'get_timeline') {\n    if (!accessToken) return { json: { error: `Twitter OAuth ${i18n.not_connected}`, help: i18n.configure } };\n    const res = await fetch(`https://api.twitter.com/2/users/me/timeline?max_results=${input.limit || 20}&tweet.fields=created_at,public_metrics,author_id`, {\n      headers: { 'Authorization': `Bearer ${accessToken}` }\n    });\n    const data = await res.json();\n    const tweets = (data.data || []).map(t => ({\n      id: t.id,\n      text: t.text,\n      author_id: t.author_id,\n      created_at: t.created_at,\n      likes: t.public_metrics?.like_count || 0,\n      retweets: t.public_metrics?.retweet_count || 0\n    }));\n    return { json: { tweets, count: tweets.length, platform: 'twitter' } };\n  }\n}\n\n// ══════════════════════════════════════════════════════════════\n// YOUTUBE\n// ══════════════════════════════════════════════════════════════\nif (platform === 'youtube') {\n  const apiKey = creds.youtube_api_key || persona.youtube_api_key || '';\n  const accessToken = persona.youtube_access_token || creds.google_access_token || persona.google_access_token || '';\n\n  if (action === 'get_subscription_feed') {\n    if (!accessToken) return { json: { error: `YouTube OAuth ${i18n.not_connected}`, help: i18n.configure } };\n    const res = await fetch(`https://www.googleapis.com/youtube/v3/subscriptions?part=snippet&mine=true&maxResults=${input.limit || 10}&order=relevance`, {\n      headers: { 'Authorization': `Bearer ${accessToken}` }\n    });\n    const data = await res.json();\n    const subs = (data.items || []).map(s => ({\n      channel: s.snippet?.title,\n      channel_id: s.snippet?.resourceId?.channelId,\n      description: s.snippet?.description?.slice(0, 100)\n    }));\n    return { json: { subscriptions: subs, count: subs.length, platform: 'youtube' } };\n  }\n\n  if (action === 'get_feed' || action === 'get_activities') {\n    if (!accessToken) return { json: { error: `YouTube OAuth ${i18n.not_connected}`, help: i18n.configure } };\n    const res = await fetch(`https://www.googleapis.com/youtube/v3/activities?part=snippet,contentDetails&home=true&maxResults=${input.limit || 20}`, {\n      headers: { 'Authorization': `Bearer ${accessToken}` }\n    });\n    const data = await res.json();\n    const activities = (data.items || []).map(a => ({\n      type: a.snippet?.type,\n      title: a.snippet?.title,\n      channel: a.snippet?.channelTitle,\n      video_id: a.contentDetails?.upload?.videoId,\n      published: a.snippet?.publishedAt,\n      url: a.contentDetails?.upload?.videoId ? `https://youtube.com/watch?v=${a.contentDetails.upload.videoId}` : null\n    })).filter(a => a.video_id);\n    return { json: { activities, count: activities.length, platform: 'youtube' } };\n  }\n\n  if (action === 'get_channel_videos') {\n    if (!apiKey) return { json: { error: `YouTube API key ${i18n.not_connected}`, help: i18n.configure } };\n    const res = await fetch(`https://www.googleapis.com/youtube/v3/search?part=snippet&channelId=${input.channel_id}&maxResults=${input.limit || 10}&order=date&type=video&key=${apiKey}`);\n    const data = await res.json();\n    const videos = (data.items || []).map(v => ({\n      video_id: v.id?.videoId,\n      title: v.snippet?.title,\n      published: v.snippet?.publishedAt,\n      url: `https://youtube.com/watch?v=${v.id?.videoId}`\n    }));\n    return { json: { videos, count: videos.length, platform: 'youtube' } };\n  }\n\n  if (action === 'search_videos') {\n    if (!apiKey) return { json: { error: `YouTube API key ${i18n.not_connected}`, help: i18n.configure } };\n    const res = await fetch(`https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(input.query || '')}&maxResults=${input.limit || 5}&type=video&key=${apiKey}`);\n    const data = await res.json();\n    const videos = (data.items || []).map(v => ({\n      video_id: v.id?.videoId,\n      title: v.snippet?.title,\n      channel: v.snippet?.channelTitle,\n      url: `https://youtube.com/watch?v=${v.id?.videoId}`\n    }));\n    return { json: { videos, count: videos.length } };\n  }\n}\n\n// ══════════════════════════════════════════════════════════════\n// REDDIT\n// ══════════════════════════════════════════════════════════════\nif (platform === 'reddit') {\n  const accessToken = creds.reddit_access_token || persona.reddit_access_token || '';\n\n  if (action === 'get_feed' || action === 'search_reddit') {\n    const subreddit = input.subreddit || 'all';\n    const sort = input.filter || 'hot';\n\n    if (!accessToken) {\n      const res = await fetch(`https://www.reddit.com/r/${subreddit}/${sort}.json?limit=${input.limit || 20}`, {\n        headers: { 'User-Agent': 'Sunday-AI/1.0' }\n      });\n      const data = await res.json();\n      const posts = (data.data?.children || []).map(p => ({\n        id: p.data.id,\n        title: p.data.title,\n        author: p.data.author,\n        subreddit: p.data.subreddit,\n        url: `https://reddit.com${p.data.permalink}`,\n        score: p.data.score,\n        comments: p.data.num_comments,\n        created: new Date(p.data.created_utc * 1000).toISOString()\n      }));\n      return { json: { posts, count: posts.length, subreddit, platform: 'reddit' } };\n    }\n\n    const res = await fetch(`https://oauth.reddit.com/r/${subreddit}/${sort}?limit=${input.limit || 20}`, {\n      headers: { \n        'Authorization': `Bearer ${accessToken}`,\n        'User-Agent': 'Sunday-AI/1.0'\n      }\n    });\n    const data = await res.json();\n    const posts = (data.data?.children || []).map(p => ({\n      id: p.data.id,\n      title: p.data.title,\n      author: p.data.author,\n      subreddit: p.data.subreddit,\n      url: `https://reddit.com${p.data.permalink}`,\n      score: p.data.score,\n      comments: p.data.num_comments\n    }));\n    return { json: { posts, count: posts.length, subreddit, platform: 'reddit' } };\n  }\n}\n\n// ══════════════════════════════════════════════════════════════\n// FACEBOOK\n// ══════════════════════════════════════════════════════════════\nif (platform === 'facebook') {\n  const accessToken = creds.facebook_access_token || persona.facebook_access_token || '';\n  if (!accessToken) return { json: { error: `Facebook ${i18n.not_connected}`, help: i18n.configure } };\n\n  if (action === 'post_facebook' || action === 'post') {\n    const pageId = input.page_id || 'me';\n    const res = await fetch(`https://graph.facebook.com/v18.0/${pageId}/feed`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ message: input.content || '', access_token: accessToken })\n    });\n    const data = await res.json();\n    if (data.error) return { json: { error: data.error.message } };\n    return { json: { success: true, message: i18n.success, post_id: data.id, platform: 'facebook' } };\n  }\n\n  if (action === 'get_feed') {\n    const pageId = input.page_id || 'me';\n    const res = await fetch(`https://graph.facebook.com/v18.0/${pageId}/feed?limit=${input.limit || 20}&access_token=${accessToken}`);\n    const data = await res.json();\n    const posts = (data.data || []).map(p => ({\n      id: p.id,\n      message: p.message || '',\n      created_time: p.created_time,\n      type: p.type\n    }));\n    return { json: { posts, count: posts.length, platform: 'facebook' } };\n  }\n}\n\n// ══════════════════════════════════════════════════════════════\n// LINKEDIN\n// ══════════════════════════════════════════════════════════════\nif (platform === 'linkedin') {\n  const accessToken = creds.linkedin_access_token || persona.linkedin_access_token || '';\n  if (!accessToken) return { json: { error: `LinkedIn ${i18n.not_connected}`, help: i18n.configure } };\n\n  if (action === 'post' || action === 'post_linkedin') {\n    const profileRes = await fetch('https://api.linkedin.com/v2/userinfo', {\n      headers: { 'Authorization': `Bearer ${accessToken}` }\n    });\n    const profile = await profileRes.json();\n    const authorUrn = `urn:li:person:${profile.sub}`;\n\n    const res = await fetch('https://api.linkedin.com/v2/ugcPosts', {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n        'Content-Type': 'application/json',\n        'X-Restli-Protocol-Version': '2.0.0'\n      },\n      body: JSON.stringify({\n        author: authorUrn,\n        lifecycleState: 'PUBLISHED',\n        specificContent: {\n          'com.linkedin.ugc.ShareContent': {\n            shareCommentary: { text: input.content || '' },\n            shareMediaCategory: 'NONE'\n          }\n        },\n        visibility: { 'com.linkedin.ugc.MemberNetworkVisibility': 'PUBLIC' }\n      })\n    });\n    const data = await res.json();\n    if (data.status >= 400) return { json: { error: data.message || i18n.error } };\n    return { json: { success: true, message: i18n.success, post_id: data.id, platform: 'linkedin' } };\n  }\n\n  if (action === 'get_feed' || action === 'get_my_posts') {\n    const profileRes = await fetch('https://api.linkedin.com/v2/userinfo', {\n      headers: { 'Authorization': `Bearer ${accessToken}` }\n    });\n    const profile = await profileRes.json();\n    const authorUrn = `urn:li:person:${profile.sub}`;\n\n    const res = await fetch(`https://api.linkedin.com/v2/ugcPosts?q=authors&authors=${encodeURIComponent(authorUrn)}&count=${input.limit || 10}`, {\n      headers: { 'Authorization': `Bearer ${accessToken}` }\n    });\n    const data = await res.json();\n    const posts = (data.elements || []).map(p => ({\n      id: p.id,\n      text: p.specificContent?.['com.linkedin.ugc.ShareContent']?.shareCommentary?.text || '',\n      created: p.created?.time,\n      url: `https://linkedin.com/feed/update/${p.id}`\n    }));\n    return { json: { posts, count: posts.length, platform: 'linkedin', note: 'LinkedIn API only returns your own posts' } };\n  }\n}\n\n// ══════════════════════════════════════════════════════════════\n// CROSS-PLATFORM: Feed Summary\n// ══════════════════════════════════════════════════════════════\nif (action === 'get_feed_summary') {\n  const results = {};\n\n  if (persona.twitter_access_token) {\n    try {\n      const res = await fetch('https://api.twitter.com/2/users/me/timeline?max_results=10&tweet.fields=public_metrics', {\n        headers: { 'Authorization': `Bearer ${persona.twitter_access_token}` }\n      });\n      const data = await res.json();\n      results.twitter = (data.data || []).slice(0, 5).map(t => ({\n        text: t.text,\n        likes: t.public_metrics?.like_count || 0\n      }));\n    } catch (e) {\n      results.twitter_error = e.message;\n    }\n  }\n\n  const ytToken = persona.youtube_access_token || creds.google_access_token || persona.google_access_token;\n  if (ytToken) {\n    try {\n      const res = await fetch('https://www.googleapis.com/youtube/v3/activities?part=snippet&home=true&maxResults=10', {\n        headers: { 'Authorization': `Bearer ${ytToken}` }\n      });\n      const data = await res.json();\n      results.youtube = (data.items || []).slice(0, 5).map(a => ({\n        title: a.snippet?.title,\n        channel: a.snippet?.channelTitle,\n        type: a.snippet?.type\n      }));\n    } catch (e) {\n      results.youtube_error = e.message;\n    }\n  }\n\n  try {\n    const subreddit = input.subreddit || 'all';\n    const res = await fetch(`https://www.reddit.com/r/${subreddit}/hot.json?limit=10`, {\n      headers: { 'User-Agent': 'Sunday-AI/1.0' }\n    });\n    const data = await res.json();\n    results.reddit = (data.data?.children || []).slice(0, 5).map(p => ({\n      title: p.data.title,\n      subreddit: p.data.subreddit,\n      score: p.data.score\n    }));\n  } catch (e) {\n    results.reddit_error = e.message;\n  }\n\n  return { \n    json: { \n      summary: results, \n      platform: 'multi',\n      note: 'Aggregated feed from all connected platforms.'\n    } \n  };\n}\n\nreturn { json: { error: `${i18n.error}: Unknown platform/action: ${platform}/${action}. Platforms: twitter, youtube, reddit, facebook, linkedin` } };"
      },
      "id": "890a8e54-ef6f-4cac-ab53-100eb3825ca7",
      "name": "manage_social",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        2512,
        432
      ]
    },
    {
      "parameters": {
        "name": "send_line_notification",
        "description": "Send urgent notification to user via LINE Notify. Use for: urgent emails from VIPs, meetings starting in <15min, critical mentions. Always explain WHY notification is needed.",
        "jsCode": "const input = JSON.parse($input.first().json.query || '{}');\nconst creds = $('Load Credentials').first().json.credentials || {};\nconst i18n = $('Load Credentials').first().json.i18n || {};\nconst token = creds.line_notify_token || '';\n\nif (!token) {\n  return { \n    json: { \n      error: `LINE Notify ${i18n.not_connected}`,\n      help: i18n.configure\n    } \n  };\n}\n\nconst message = input.message || '';\n\nif (!message) {\n  return { \n    json: { \n      error: i18n.error || 'Message is required'\n    } \n  };\n}\n\ntry {\n  const res = await fetch('https://notify-api.line.me/api/notify', {\n    method: 'POST',\n    headers: {\n      'Authorization': `Bearer ${token}`,\n      'Content-Type': 'application/x-www-form-urlencoded'\n    },\n    body: new URLSearchParams({ message })\n  });\n\n  const data = await res.json();\n\n  if (!res.ok || data.status !== 200) {\n    return { \n      json: { \n        error: i18n.error || 'Failed to send notification',\n        details: data.message || 'Unknown error',\n        status: data.status\n      } \n    };\n  }\n\n  return { \n    json: {\n      success: true,\n      message: i18n.success || 'Sent',\n      status: data.status\n    } \n  };\n\n} catch (error) {\n  return { \n    json: { \n      error: i18n.error || 'Network error',\n      details: error.message\n    } \n  };\n}"
      },
      "id": "5a5d0f7a-1e3a-4ec8-9a80-74ea4cc2f428",
      "name": "Line Notify Tool",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1,
      "position": [
        2656,
        432
      ]
    },
    {
      "parameters": {
        "jsCode": "const agentOutput = $input.first().json.output || $input.first().json.text || 'เสร็จแล้วครับ';\nconst prev = $('Extract Payload').item.json;\nreturn {\n  json: {\n    ...prev,\n    agentOutput: agentOutput,\n    agentCategory: 'secretary',\n    processedAt: new Date().toISOString()\n  }\n};"
      },
      "id": "9072d845-9434-4caa-8096-2e91f1f66975",
      "name": "Format Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2768,
        192
      ]
    },
    {
      "parameters": {
        "model": "anthropic/claude-haiku-4.5",
        "options": {
          "maxTokens": 2500
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        1328,
        432
      ],
      "id": "b3f40554-b6b5-42bd-982a-6949c7f95d2e",
      "name": "OpenRouter LLM (Haiku)",
      "credentials": {
        "openRouterApi": {
          "id": "FUm3Fg9B8euy8cH3",
          "name": "OpenRouter - 2026-02-14T03:30"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "WF3-A Entry": {
      "main": [
        [
          {
            "node": "Extract Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Payload": {
      "main": [
        [
          {
            "node": "Load Credentials",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Credentials": {
      "main": [
        [
          {
            "node": "Secretary Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Secretary Agent": {
      "main": [
        [
          {
            "node": "Format Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Session Memory": {
      "ai_memory": [
        [
          {
            "node": "Secretary Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "think": {
      "ai_tool": [
        [
          {
            "node": "Secretary Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "manage_calendar": {
      "ai_tool": [
        [
          {
            "node": "Secretary Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "manage_tasks": {
      "ai_tool": [
        [
          {
            "node": "Secretary Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "manage_email": {
      "ai_tool": [
        [
          {
            "node": "Secretary Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "manage_chat": {
      "ai_tool": [
        [
          {
            "node": "Secretary Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "manage_social": {
      "ai_tool": [
        [
          {
            "node": "Secretary Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Line Notify Tool": {
      "ai_tool": [
        [
          {
            "node": "Secretary Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter LLM (Haiku)": {
      "ai_languageModel": [
        [
          {
            "node": "Secretary Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "binaryMode": "separate",
    "availableInMCP": false
  },
  "versionId": "781794b7-384d-4002-9919-3a301f9cc7dc",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "c3a8077648ce894608db1ade94831096370fb6a0453430d193f6c81b3c8cc1cb"
  },
  "id": "jFLKKUlD5IjPbaOS",
  "tags": []
}
