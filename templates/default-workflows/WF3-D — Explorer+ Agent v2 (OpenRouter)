{
  "name": "WF3-D — Explorer+ Agent v2 (OpenRouter)",
  "nodes": [
    {
      "parameters": {
        "content": "# WF3-D — EXPLORER+ v2\n## 6 Code Tools\n1. web_search       → Brave + Wikipedia + URL fetch\n2. get_weather      → Current + 5-day forecast\n3. find_places      → Google Maps + YouTube search\n4. dev_tools        → GitHub + npm + PyPI + HTTP test\n5. rag_search       → Personal knowledge base (OpenRouter embed)\n6. search_memories  → Past conversations (OpenRouter embed)\n\nModel: Gemini Flash (large context, fast)\n\n## KEY CHANGES:\n- rag_search: ใช้ OpenRouter embed (user key) แทน Gating Service\n- search_memories: ใช้ OpenRouter embed (user key)\n- ไม่ต้องการ GATING_SERVICE_URL อีกต่อไป\n\n## MULTILINGUAL: th / en / ja / zh",
        "height": 320,
        "width": 380,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -272,
        -96
      ],
      "id": "c60146d7-8e92-4336-990e-e71b32d6ad1c",
      "name": "Explorer+ v2 Overview"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "wf3d-explorer",
        "responseMode": "lastNode",
        "options": {}
      },
      "id": "6038d40f-56de-4b60-86d5-aab927a71dbb",
      "name": "WF3-D Entry1",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        592,
        256
      ],
      "webhookId": "wf3d-explorer-entry"
    },
    {
      "parameters": {
        "jsCode": "const p = $input.first().json.body || $input.first().json;\nreturn { json: {\n  userId: p.userId, sessionId: p.sessionId, source: p.source,\n  message: p.message || p.enrichedMessage,\n  originalMessage: p.originalMessage || p.message,\n  persona: typeof p.persona === 'string' ? JSON.parse(p.persona) : (p.persona || {}),\n  replyTarget: p.replyTarget, replyToken: p.replyToken, timestamp: p.timestamp\n}};"
      },
      "id": "c3d5ac81-42b2-42a2-ab83-04172f987414",
      "name": "Extract Payload1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        880,
        256
      ]
    },
    {
      "parameters": {
        "jsCode": "// Load Credentials — MULTILINGUAL + i18n\nconst prev = $('Extract Payload1').first().json;\nconst p = prev.persona || {};\nconst t = p.tokens || {};\nconst lang = p.language_preference || 'th';\n\nconst i18nMap = {\n  th: {\n    not_connected: 'ยังไม่ได้เชื่อมต่อ',\n    configure: 'กรุณาตั้งค่าที่ /dashboard/api-settings',\n    success: 'สำเร็จ',\n    error: 'เกิดข้อผิดพลาด',\n    completed: 'เสร็จแล้ว',\n    query_required: 'กรุณาระบุคำค้นหา',\n    url_required: 'กรุณาระบุ URL',\n    city_required: 'กรุณาระบุชื่อเมือง',\n    repo_required: 'กรุณาระบุ repo (เช่น user/repo)',\n    package_required: 'กรุณาระบุชื่อแพ็กเกจ',\n    github_username_missing: 'ยังไม่ได้ตั้งค่า github_username ใน persona'\n  },\n  en: {\n    not_connected: 'Not connected',\n    configure: 'Please configure at /dashboard/api-settings',\n    success: 'Success',\n    error: 'Error occurred',\n    completed: 'Completed',\n    query_required: 'query is required',\n    url_required: 'url is required',\n    city_required: 'city is required',\n    repo_required: 'repo required (e.g. user/repo)',\n    package_required: 'package name is required',\n    github_username_missing: 'github_username not set in persona'\n  },\n  ja: {\n    not_connected: '接続されていません',\n    configure: '/dashboard/api-settingsで設定してください',\n    success: '成功しました',\n    error: 'エラーが発生しました',\n    completed: '完了しました',\n    query_required: '検索クエリが必要です',\n    url_required: 'URLが必要です',\n    city_required: '都市名が必要です',\n    repo_required: 'リポジトリが必要です（例: user/repo）',\n    package_required: 'パッケージ名が必要です',\n    github_username_missing: 'personaにgithub_usernameが設定されていません'\n  },\n  zh: {\n    not_connected: '未连接',\n    configure: '请在 /dashboard/api-settings 配置',\n    success: '成功',\n    error: '发生错误',\n    completed: '已完成',\n    query_required: '需要查询关键词',\n    url_required: '需要URL',\n    city_required: '需要城市名称',\n    repo_required: '需要仓库名（例如 user/repo）',\n    package_required: '需要包名',\n    github_username_missing: 'persona中未设置github_username'\n  }\n};\n\nconst i18n = i18nMap[lang] || i18nMap['en'];\n\nconst get = (envKey, payloadKey) =>\n  t[payloadKey] || p[payloadKey] || process.env[envKey] || '';\n\nconst creds = {\n  google_access_token:    get('GOOGLE_ACCESS_TOKEN',    'google_access_token'),\n  google_refresh_token:   get('GOOGLE_REFRESH_TOKEN',   'google_refresh_token'),\n  microsoft_access_token: get('MICROSOFT_ACCESS_TOKEN', 'microsoft_access_token'),\n  outlook_access_token:   get('MICROSOFT_ACCESS_TOKEN', 'microsoft_access_token'),\n  telegram_bot_token:     get('TELEGRAM_BOT_TOKEN',     'telegram_bot_token'),\n  discord_bot_token:      get('DISCORD_BOT_TOKEN',      'discord_bot_token'),\n  slack_bot_token:        get('SLACK_BOT_TOKEN',        'slack_bot_token'),\n  twitter_bearer_token:   get('TWITTER_BEARER_TOKEN',   'twitter_bearer_token'),\n  facebook_access_token:  get('FACEBOOK_ACCESS_TOKEN',  'facebook_access_token'),\n  linkedin_access_token:  get('LINKEDIN_ACCESS_TOKEN',  'linkedin_access_token'),\n  spotify_access_token:   get('SPOTIFY_ACCESS_TOKEN',   'spotify_access_token'),\n  youtube_api_key:        get('YOUTUBE_API_KEY',        'youtube_api_key'),\n  line_notify_token:      get('LINE_NOTIFY_TOKEN',      'line_notify_token'),\n  google_maps_key:        get('GOOGLE_MAPS_API_KEY',    'google_maps_key'),\n  brave_api_key:          get('BRAVE_API_KEY',          'brave_api_key'),\n  openweathermap_key:     get('OPENWEATHERMAP_API_KEY', 'openweathermap_key'),\n  fal_api_key:            get('FAL_API_KEY',            'fal_api_key'),\n  elevenlabs_api_key:     get('ELEVENLABS_API_KEY',     'elevenlabs_api_key'),\n  unsplash_access_key:    get('UNSPLASH_ACCESS_KEY',    'unsplash_access_key'),\n  nutritionix_app_id:     get('NUTRITIONIX_APP_ID',     'nutritionix_app_id'),\n  nutritionix_api_key:    get('NUTRITIONIX_API_KEY',    'nutritionix_api_key'),\n  finnhub_api_key:        get('FINNHUB_API_KEY',        'finnhub_api_key'),\n  ha_url:                 get('HOME_ASSISTANT_URL',      'ha_url'),\n  ha_token:               get('HOME_ASSISTANT_TOKEN',    'ha_token'),\n  sonos_api_url:          get('SONOS_HTTP_API_URL',     'sonos_api_url'),\n  lastfm_api_key:         get('LASTFM_API_KEY',         'lastfm_api_key'),\n  internal_auth_token:    get('INTERNAL_AUTH_TOKEN',    'internal_auth_token'),\n  n8n_base_url:           get('N8N_BASE_URL',           'n8n_base_url'),\n  database_url:           get('DATABASE_URL',           'database_url'),\n  github_token:           get('GITHUB_TOKEN',           'github_token')\n};\n\nconst connected = Object.entries(creds).filter(([k,v]) => v).map(([k]) => k);\n\nconsole.log('[Load Credentials]', {\n  userId: prev.userId?.substring(0, 8) + '...',\n  connected: connected.length,\n  lang\n});\n\nreturn { \n  json: { \n    ...prev, \n    credentials: creds, \n    lang,\n    i18n,\n    _connected: connected \n  } \n};"
      },
      "id": "c55663ba-65fa-4af5-8e46-61d862468e5e",
      "name": "Load Credentials",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1136,
        256
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.message }}",
        "options": {
          "systemMessage": "=You are Explorer+ — expert researcher and knowledge navigator.\n\nUser: {{ $json.persona.name || 'User' }}\nLanguage: {{ $json.persona.language_preference || 'th' }}\n\n## LANGUAGE RULES:\n**ALWAYS respond in user's preferred language: {{ $json.persona.language_preference }}**\n- If 'th' → Thai\n- If 'en' → English\n- If 'ja' → Japanese\n- If 'zh' → Chinese\n\n## TOOLS:\nweb_search, get_weather, find_places, dev_tools, rag_search, search_memories, think\n\n## APPROACH:\n- Use web_search for current information and research\n- Use rag_search to check user's personal knowledge base first\n- Use search_memories when user asks about past experiences or conversations\n- Synthesize multiple sources when needed\n- Cite sources clearly in your response"
        }
      },
      "id": "f23a85ec-b9dc-448f-a323-778b0ff52721",
      "name": "Explorer+ Agent1",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.8,
      "position": [
        1632,
        144
      ]
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $('Load Credentials').item.json.sessionId }}"
      },
      "id": "62784f67-a26a-4645-bab1-72b8ce73cba0",
      "name": "Session Memory1",
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        1584,
        384
      ]
    },
    {
      "parameters": {},
      "id": "d155f738-e6c6-4a14-8f4d-c7a85d65ab55",
      "name": "think1",
      "type": "@n8n/n8n-nodes-langchain.toolThink",
      "typeVersion": 1,
      "position": [
        1728,
        384
      ]
    },
    {
      "parameters": {
        "name": "search_memories",
        "description": "Search past conversations and memories semantically using vector similarity. Use when user asks about: past experiences, places visited, previous discussions, things they mentioned before, personal preferences they stated in the past.",
        "jsCode": "// search_memories — OpenAI embedding + pgvector cosine search\n// dim=1536 (text-embedding-3-small) — ตรงกับ WF5-B Process Gating\nconst input = JSON.parse($input.first().json.query || '{}');\nconst query = input.query || input.q || '';\nconst limit = input.limit || 3;\n\nconst creds = $('Load Credentials').first().json.credentials || {};\nconst i18n = $('Load Credentials').first().json.i18n || {};\nconst userId = $('Load Credentials').first().json.userId;\nconst dbUrl = creds.database_url || process.env.DATABASE_URL || '';\nconst openaiKey = creds.google_access_token\n  ? null  // will be overridden below\n  : null;\n\n// Get OpenRouter key from user tokens (ใช้ key เดิมที่มีอยู่แล้ว)\nconst persona = $('Load Credentials').first().json.persona || {};\nconst tokens = persona.tokens || {};\nconst embedKey = tokens.openrouter_access_token || process.env.OPENROUTER_API_KEY || '';\n\nif (!dbUrl) {\n  return { json: { error: `Database ${i18n.not_connected || 'not connected'}`, memories: [] } };\n}\nif (!query || query.length < 3) {\n  return { json: { error: 'Query too short (min 3 chars)', memories: [] } };\n}\nif (!embedKey) {\n  return { json: { error: 'OpenRouter key not configured', memories: [] } };\n}\n\ntry {\n  // ── Step 1: Generate embedding via OpenRouter ─────────────\n  const embedRes = await fetch('https://openrouter.ai/api/v1/embeddings', {\n    method: 'POST',\n    headers: {\n      'Authorization': `Bearer ${embedKey}`,\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      model: 'openai/text-embedding-3-small',\n      input: query\n    })\n  });\n\n  if (!embedRes.ok) {\n    const err = await embedRes.text();\n    return { json: { error: `OpenRouter embed failed: ${embedRes.status} ${err}`, memories: [] } };\n  }\n\n  const embedData = await embedRes.json();\n  const embedding = embedData.data?.[0]?.embedding;\n\n  if (!embedding || !Array.isArray(embedding)) {\n    return { json: { error: 'No embedding returned', memories: [] } };\n  }\n\n  console.log(`[search_memories] dim=${embedding.length} query=\"${query}\"`);\n\n  // ── Step 2: pgvector cosine similarity search ─────────────\n  const { Pool } = require('pg');\n  const pool = new Pool({ connectionString: dbUrl });\n\n  const vectorStr = `[${embedding.join(',')}]`;\n\n  const result = await pool.query(\n    `SELECT\n       content,\n       metadata,\n       created_at,\n       1 - (embedding <=> $1::vector) AS similarity\n     FROM user_data_schema.memory_embeddings\n     WHERE user_id = $2\n       AND embedding IS NOT NULL\n       AND 1 - (embedding <=> $1::vector) > 0.6\n     ORDER BY embedding <=> $1::vector\n     LIMIT $3`,\n    [vectorStr, userId, limit]\n  );\n\n  await pool.end();\n\n  const memories = result.rows.map(r => ({\n    content: r.content,\n    similarity: parseFloat(r.similarity.toFixed(3)),\n    metadata: r.metadata || {},\n    date: new Date(r.created_at).toLocaleDateString('th-TH')\n  }));\n\n  console.log(`[search_memories] Found ${memories.length} | top=${memories[0]?.similarity || 0}`);\n\n  if (memories.length === 0) {\n    return { json: { message: 'No relevant memories found', memories: [], query } };\n  }\n\n  return { json: { memories, count: memories.length, query } };\n\n} catch(err) {\n  console.error('[search_memories] Error:', err.message);\n  return { json: { error: `${i18n.error || 'Error'}: ${err.message}`, memories: [] } };\n}"
      },
      "id": "2fd47ca7-7680-4b34-95cb-718ebe9ba3c6",
      "name": "search_memories",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        1840,
        384
      ]
    },
    {
      "parameters": {
        "name": "web_search",
        "description": "Search the web or fetch page. search_type: brave_search (requires: query), wikipedia (requires: query, lang th|en), fetch_url (requires: url).",
        "jsCode": "const input = JSON.parse($input.first().json.query || '{}');\nconst ctx = $('Load Credentials').first().json;\nconst creds = ctx.credentials || {};\nconst i18n = ctx.i18n || {};\nconst searchType = (input.search_type || 'brave_search').toLowerCase();\n\ntry {\n  if (searchType === 'brave_search') {\n    if (!input.query) return { json: { error: i18n.query_required || 'query required' } };\n    const braveKey = creds.brave_api_key || '';\n    if (!braveKey) return { json: { error: `Brave API key ${i18n.not_connected}`, help: i18n.configure } };\n    const res = await fetch(`https://api.search.brave.com/res/v1/web/search?q=${encodeURIComponent(input.query)}&count=8&country=th`, {\n      headers: { 'Accept': 'application/json', 'X-Subscription-Token': braveKey }\n    });\n    const data = await res.json();\n    const results = (data.web?.results || []).map(r => ({ title: r.title, url: r.url, snippet: r.description }));\n    return { json: { query: input.query, results, count: results.length } };\n  }\n\n  if (searchType === 'wikipedia') {\n    if (!input.query) return { json: { error: i18n.query_required || 'query required' } };\n    const wikiLang = input.lang === 'th' ? 'th' : 'en';\n    const title = encodeURIComponent(input.query.replace(/ /g, '_'));\n    const res = await fetch(`https://${wikiLang}.wikipedia.org/api/rest_v1/page/summary/${title}`);\n    if (res.status === 404) return { json: { error: `Wikipedia: '${input.query}' not found in ${wikiLang}` } };\n    const data = await res.json();\n    return { json: { title: data.title, summary: data.extract, url: data.content_urls?.desktop?.page, lang: wikiLang } };\n  }\n\n  if (searchType === 'fetch_url') {\n    if (!input.url) return { json: { error: i18n.url_required || 'url required' } };\n    const res = await fetch(input.url, { headers: { 'User-Agent': 'Sunday-JARVIS/3.0' } });\n    if (!res.ok) return { json: { error: `HTTP ${res.status}`, url: input.url } };\n    const text = await res.text();\n    const clean = text.replace(/<[^>]+>/g, ' ').replace(/\\s+/g, ' ').trim().slice(0, 3000);\n    return { json: { url: input.url, content: clean, length: clean.length } };\n  }\n\n  return { json: { error: `Unknown search_type: ${searchType}. Use: brave_search, wikipedia, fetch_url` } };\n} catch(e) {\n  return { json: { error: e.message } };\n}"
      },
      "id": "285a2d60-1303-4a02-ab7c-789ffb09e339",
      "name": "web_search1",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        1968,
        384
      ]
    },
    {
      "parameters": {
        "name": "get_weather",
        "description": "Get weather data. weather_type: current (current conditions), forecast_5day (5-day forecast). Requires: city (e.g. Bangkok, Chiang Mai).",
        "jsCode": "const input = JSON.parse($input.first().json.query || '{}');\nconst ctx = $('Load Credentials').first().json;\nconst creds = ctx.credentials || {};\nconst i18n = ctx.i18n || {};\nconst weatherType = (input.weather_type || 'current').toLowerCase();\nconst city = input.city || ctx.persona?.location || 'Bangkok';\nconst owmKey = creds.openweathermap_key || '';\n\nif (!owmKey) return { json: { error: `OpenWeatherMap ${i18n.not_connected}`, help: i18n.configure } };\n\nconst owmLangMap = { th: 'th', en: 'en', ja: 'ja', zh: 'zh_cn' };\nconst owmLang = owmLangMap[ctx.lang || 'th'] || 'en';\n\ntry {\n  if (weatherType === 'current') {\n    const res = await fetch(`https://api.openweathermap.org/data/2.5/weather?q=${encodeURIComponent(city)}&appid=${owmKey}&units=metric&lang=${owmLang}`);\n    const d = await res.json();\n    if (d.cod !== 200) return { json: { error: d.message, city } };\n    return { json: { city: d.name, country: d.sys?.country, temp_c: d.main?.temp, feels_like: d.main?.feels_like, humidity_pct: d.main?.humidity, description: d.weather?.[0]?.description, wind_kph: Math.round((d.wind?.speed || 0) * 3.6), visibility_km: (d.visibility || 0) / 1000 }};\n  }\n\n  if (weatherType === 'forecast_5day') {\n    const res = await fetch(`https://api.openweathermap.org/data/2.5/forecast?q=${encodeURIComponent(city)}&appid=${owmKey}&units=metric&lang=${owmLang}&cnt=40`);\n    const d = await res.json();\n    if (d.cod !== '200') return { json: { error: d.message, city } };\n    const byDay = {};\n    for (const item of d.list) {\n      const day = item.dt_txt.split(' ')[0];\n      if (!byDay[day]) byDay[day] = [];\n      byDay[day].push(item);\n    }\n    const forecast = Object.entries(byDay).slice(0, 5).map(([date, items]) => ({\n      date,\n      temp_max: Math.max(...items.map(i => i.main.temp_max)),\n      temp_min: Math.min(...items.map(i => i.main.temp_min)),\n      description: items[Math.floor(items.length/2)].weather[0].description,\n      rain_chance: Math.round(Math.max(...items.map(i => (i.pop || 0) * 100)))\n    }));\n    return { json: { city: d.city?.name, forecast, days: forecast.length } };\n  }\n\n  return { json: { error: `Unknown weather_type: ${weatherType}. Use: current, forecast_5day` } };\n} catch(e) {\n  return { json: { error: e.message } };\n}"
      },
      "id": "7e16c317-19f2-4fdc-8f95-e4c8fbcec7e2",
      "name": "get_weather1",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        2160,
        384
      ]
    },
    {
      "parameters": {
        "name": "find_places",
        "description": "Find nearby places or search YouTube. search_type: nearby_places (requires: query, optional: location e.g. Bangkok), youtube_search (requires: query, optional: max_results).",
        "jsCode": "const input = JSON.parse($input.first().json.query || '{}');\nconst ctx = $('Load Credentials').first().json;\nconst creds = ctx.credentials || {};\nconst i18n = ctx.i18n || {};\nconst searchType = (input.search_type || 'nearby_places').toLowerCase();\n\ntry {\n  if (searchType === 'nearby_places') {\n    const mapsKey = creds.google_maps_key || '';\n    if (!mapsKey) return { json: { error: `Google Maps API key ${i18n.not_connected}`, help: i18n.configure } };\n    const lat = ctx.persona?.lat || '13.7563';\n    const lng = ctx.persona?.lng || '100.5018';\n    const mapsLang = ['th','en','ja','zh'].includes(ctx.lang) ? ctx.lang : 'en';\n    const res = await fetch(`https://maps.googleapis.com/maps/api/place/textsearch/json?query=${encodeURIComponent(input.query)}&location=${lat},${lng}&radius=5000&language=${mapsLang}&key=${mapsKey}`);\n    const data = await res.json();\n    if (data.status !== 'OK' && data.status !== 'ZERO_RESULTS') return { json: { error: data.status, message: data.error_message } };\n    const places = (data.results || []).slice(0, 5).map(p => ({ name: p.name, address: p.formatted_address, rating: p.rating, open_now: p.opening_hours?.open_now, place_id: p.place_id }));\n    return { json: { query: input.query, places, count: places.length } };\n  }\n\n  if (searchType === 'youtube_search') {\n    const ytKey = creds.youtube_api_key || '';\n    if (!ytKey) return { json: { error: `YouTube API key ${i18n.not_connected}`, help: i18n.configure } };\n    const maxResults = input.max_results || 5;\n    const res = await fetch(`https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(input.query)}&maxResults=${maxResults}&type=video&key=${ytKey}`);\n    const data = await res.json();\n    if (data.error) return { json: { error: data.error.message } };\n    const videos = (data.items || []).map(v => ({ title: v.snippet.title, channel: v.snippet.channelTitle, description: v.snippet.description?.slice(0, 100), url: `https://youtube.com/watch?v=${v.id.videoId}`, published: v.snippet.publishedAt }));\n    return { json: { query: input.query, videos, count: videos.length } };\n  }\n\n  return { json: { error: `Unknown search_type: ${searchType}. Use: nearby_places, youtube_search` } };\n} catch(e) {\n  return { json: { error: e.message } };\n}"
      },
      "id": "9e57dc18-749a-4ed4-8de9-1775b8feeae9",
      "name": "find_places1",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        2336,
        384
      ]
    },
    {
      "parameters": {
        "name": "dev_tools",
        "description": "Developer tools. tool_type: github_repos (list user repos), github_issues (requires: repo e.g. user/repo), github_search (requires: query), npm_search (requires: query), pypi_info (requires: package), http_test (requires: url, method GET|POST|etc).",
        "jsCode": "const input = JSON.parse($input.first().json.query || '{}');\nconst ctx = $('Load Credentials').first().json;\nconst creds = ctx.credentials || {};\nconst i18n = ctx.i18n || {};\nconst toolType = (input.tool_type || 'github_repos').toLowerCase();\nconst ghToken = creds.github_token || '';\nconst ghHeaders = {\n  'Accept': 'application/vnd.github.v3+json',\n  ...(ghToken ? { 'Authorization': `Bearer ${ghToken}` } : {})\n};\n\ntry {\n  if (toolType === 'github_repos') {\n    const username = ctx.persona?.github_username || input.username;\n    if (!username) return { json: { error: i18n.github_username_missing || 'github_username not set in persona' } };\n    const res = await fetch(`https://api.github.com/users/${username}/repos?sort=updated&per_page=15`, { headers: ghHeaders });\n    const data = await res.json();\n    if (!Array.isArray(data)) return { json: { error: data.message || `GitHub API ${i18n.error}` } };\n    return { json: { repos: data.map(r => ({ name: r.name, description: r.description, stars: r.stargazers_count, language: r.language, updated: r.updated_at, url: r.html_url })), count: data.length } };\n  }\n  if (toolType === 'github_issues') {\n    if (!input.repo) return { json: { error: i18n.repo_required || 'repo required (e.g. user/repo)' } };\n    const state = input.state || 'open';\n    const res = await fetch(`https://api.github.com/repos/${input.repo}/issues?state=${state}&per_page=15`, { headers: ghHeaders });\n    const data = await res.json();\n    if (!Array.isArray(data)) return { json: { error: data.message || `GitHub API ${i18n.error}` } };\n    return { json: { repo: input.repo, issues: data.filter(i => !i.pull_request).map(i => ({ number: i.number, title: i.title, state: i.state, created: i.created_at, url: i.html_url })), count: data.length } };\n  }\n  if (toolType === 'github_search') {\n    if (!input.query) return { json: { error: i18n.query_required || 'query required' } };\n    const res = await fetch(`https://api.github.com/search/repositories?q=${encodeURIComponent(input.query)}&sort=stars&per_page=8`, { headers: ghHeaders });\n    const data = await res.json();\n    return { json: { results: (data.items || []).map(r => ({ name: r.full_name, description: r.description, stars: r.stargazers_count, language: r.language, url: r.html_url })), total: data.total_count } };\n  }\n  if (toolType === 'npm_search') {\n    if (!input.query) return { json: { error: i18n.query_required || 'query required' } };\n    const res = await fetch(`https://registry.npmjs.org/-/v1/search?text=${encodeURIComponent(input.query)}&size=5`);\n    const data = await res.json();\n    return { json: { packages: (data.objects || []).map(o => ({ name: o.package.name, version: o.package.version, description: o.package.description, weekly_downloads: o.downloads?.weekly, url: `https://npmjs.com/package/${o.package.name}` })) } };\n  }\n  if (toolType === 'pypi_info') {\n    if (!input.package) return { json: { error: i18n.package_required || 'package name required' } };\n    const res = await fetch(`https://pypi.org/pypi/${input.package}/json`);\n    if (res.status === 404) return { json: { error: `Package '${input.package}' not found on PyPI` } };\n    const data = await res.json();\n    const info = data.info;\n    return { json: { name: info.name, version: info.version, summary: info.summary, author: info.author, license: info.license, home_page: info.home_page, requires_python: info.requires_python } };\n  }\n  if (toolType === 'http_test') {\n    if (!input.url) return { json: { error: i18n.url_required || 'url required' } };\n    const method = (input.method || 'GET').toUpperCase();\n    const startTime = Date.now();\n    const res = await fetch(input.url, { method, headers: { 'User-Agent': 'Sunday-JARVIS/3.0', ...(input.headers || {}) }, body: input.body ? JSON.stringify(input.body) : undefined });\n    const duration = Date.now() - startTime;\n    const text = await res.text();\n    let body;\n    try { body = JSON.parse(text); } catch { body = text.slice(0, 500); }\n    return { json: { url: input.url, method, status: res.status, ok: res.ok, duration_ms: duration, response: body } };\n  }\n  return { json: { error: `Unknown tool_type: ${toolType}. Use: github_repos, github_issues, github_search, npm_search, pypi_info, http_test` } };\n} catch(e) {\n  return { json: { error: e.message } };\n}"
      },
      "id": "cdf46ea1-2995-443a-aad0-3cd3514cabdc",
      "name": "dev_tools1",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        2512,
        384
      ]
    },
    {
      "parameters": {
        "name": "rag_search",
        "description": "Search user's personal knowledge base using semantic similarity. Requires: query (text to search for similar saved notes).",
        "jsCode": "// rag_search — OpenRouter embed + pgvector cosine search\n// Uses user's OpenRouter key (no separate gating service needed)\nconst input = JSON.parse($input.first().json.query || '{}');\nconst ctx = $('Load Credentials').first().json;\nconst creds = ctx.credentials || {};\nconst i18n = ctx.i18n || {};\n\nif (!input.query) return { json: { error: i18n.query_required || 'query required' } };\n\nconst dbUrl = creds.database_url || process.env.DATABASE_URL || '';\nconst pgUrl = (creds.n8n_base_url || process.env.N8N_BASE_URL || '') + '/webhook/internal-pg-query';\nconst headers = { 'Content-Type': 'application/json', 'x-internal-auth': creds.internal_auth_token || '' };\n\n// Get user's OpenRouter key for embedding\nconst persona = ctx.persona || {};\nconst tokens = persona.tokens || {};\nconst embedKey = tokens.openrouter_access_token || process.env.OPENROUTER_API_KEY || '';\n\ntry {\n  if (embedKey) {\n    // ── Vector path: OpenRouter embedding ─────────────────────\n    const embedRes = await fetch('https://openrouter.ai/api/v1/embeddings', {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${embedKey}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        model: 'openai/text-embedding-3-small',\n        input: input.query\n      })\n    });\n\n    if (embedRes.ok) {\n      const embedData = await embedRes.json();\n      const embedding = embedData.data?.[0]?.embedding;\n\n      if (embedding && Array.isArray(embedding)) {\n        console.log(`[rag_search] vector dim=${embedding.length}`);\n        const vectorStr = `[${embedding.join(',')}]`;\n        const res = await fetch(pgUrl, {\n          method: 'POST',\n          headers,\n          body: JSON.stringify({\n            query: `SELECT content, metadata, 1 - (embedding <=> '${vectorStr}'::vector) AS similarity\n                    FROM user_data_schema.knowledge_base\n                    WHERE user_id = '${ctx.userId}'\n                      AND embedding IS NOT NULL\n                      AND 1 - (embedding <=> '${vectorStr}'::vector) > 0.5\n                    ORDER BY embedding <=> '${vectorStr}'::vector\n                    LIMIT 5`\n          })\n        });\n        const data = await res.json();\n        return { json: { results: data.rows || [], count: data.rows?.length || 0, mode: 'vector' } };\n      }\n    }\n  }\n\n  // ── Fallback: keyword search (no embed key or embed failed) ──\n  console.log('[rag_search] fallback keyword search');\n  const q = input.query.replace(/'/g, \"''\");\n  const res = await fetch(pgUrl, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify({\n      query: `SELECT content, metadata FROM user_data_schema.knowledge_base\n              WHERE user_id = '${ctx.userId}'\n                AND content ILIKE '%${q}%'\n              LIMIT 5`\n    })\n  });\n  const data = await res.json();\n  return { json: { results: data.rows || [], mode: 'keyword_fallback', count: data.rows?.length || 0 } };\n\n} catch(e) {\n  return { json: { error: e.message } };\n}"
      },
      "id": "de410193-b37d-4d9c-bc4c-2de1d98b744a",
      "name": "rag_search1",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [
        2688,
        384
      ]
    },
    {
      "parameters": {
        "jsCode": "const out = $input.first().json.output || $input.first().json.text || 'ไม่พบข้อมูล';\nconst prev = $('Extract Payload1').item.json;\nreturn { json: { ...prev, agentOutput: out, agentCategory: 'explorer', processedAt: new Date().toISOString() } };"
      },
      "id": "996cad59-1fab-4776-baa4-29fb37a0b8f9",
      "name": "Format Output1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2896,
        144
      ]
    },
    {
      "parameters": {
        "model": "google/gemini-2.0-flash-001",
        "options": {
          "maxTokens": 6000
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        1440,
        384
      ],
      "id": "ee4802ea-4232-400a-b280-25b32f75809c",
      "name": "OpenRouter LLM (Gemini Flash)",
      "credentials": {
        "openRouterApi": {
          "id": "FUm3Fg9B8euy8cH3",
          "name": "OpenRouter - 2026-02-14T03:30"
        }
      }
    }
  ],
  "connections": {
    "WF3-D Entry1": {
      "main": [
        [
          {
            "node": "Extract Payload1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Payload1": {
      "main": [
        [
          {
            "node": "Load Credentials",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Credentials": {
      "main": [
        [
          {
            "node": "Explorer+ Agent1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Explorer+ Agent1": {
      "main": [
        [
          {
            "node": "Format Output1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Session Memory1": {
      "ai_memory": [
        [
          {
            "node": "Explorer+ Agent1",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "think1": {
      "ai_tool": [
        [
          {
            "node": "Explorer+ Agent1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "search_memories": {
      "ai_tool": [
        [
          {
            "node": "Explorer+ Agent1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "web_search1": {
      "ai_tool": [
        [
          {
            "node": "Explorer+ Agent1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "get_weather1": {
      "ai_tool": [
        [
          {
            "node": "Explorer+ Agent1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "find_places1": {
      "ai_tool": [
        [
          {
            "node": "Explorer+ Agent1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "dev_tools1": {
      "ai_tool": [
        [
          {
            "node": "Explorer+ Agent1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "rag_search1": {
      "ai_tool": [
        [
          {
            "node": "Explorer+ Agent1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter LLM (Gemini Flash)": {
      "ai_languageModel": [
        [
          {
            "node": "Explorer+ Agent1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "binaryMode": "separate",
    "availableInMCP": false
  },
  "versionId": "806d85b1-ebc7-4e16-83d9-bc54b36d1dd5",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "c3a8077648ce894608db1ade94831096370fb6a0453430d193f6c81b3c8cc1cb"
  },
  "id": "BQoG30U6TIWlunXX",
  "tags": []
}
